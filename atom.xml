<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>charonxu&#39;s Blog</title>
  
  
  <link href="http://charonxu.cn/atom.xml" rel="self"/>
  
  <link href="http://charonxu.cn/"/>
  <updated>2021-03-01T14:39:18.634Z</updated>
  <id>http://charonxu.cn/</id>
  
  <author>
    <name>charonxu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://charonxu.cn/2021/03/01/C++%E5%9F%BA%E7%A1%80/"/>
    <id>http://charonxu.cn/2021/03/01/C++%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-01T14:32:13.723Z</published>
    <updated>2021-03-01T14:39:18.634Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. .与-&gt;的区别</strong></p><pre><code>.用于实际的对象  -&gt;用于一个指针对象的指针(*x).b 等价于 x-&gt;b通俗讲 若上面使用指针申请的对象p则调用p的方法则为 p-&gt;.. 或 (*p). ... 否则若是已经创建的实体（给了空间） 就是.</code></pre><a id="more"></a><p><strong>2.指针和引用的理解与区别</strong></p><pre><code>引用是某一变量的别名 操作等同于变量指针是指向某一地址单元的值区别：1.指针有自己的一块空间 引用只是个别名2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小3.指针可以初始化NULL，而引用必须被初始化且必须是一个已有对象的引用4.作为参数传递时，指针需要被解引用才能对对象进行操作，而引用会直接修改所指向的对象5.可以有const指针，不能有const引用6.指针在使用中可以指向其他对象，但引用智能对一个对象引用，不能改变7.指针可以有多级指针（**P） 但引用只有一级8.指针和引用的++意义不同</code></pre><p><strong>3.深拷贝与浅拷贝</strong></p><pre><code>深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用假设B复制了A，修改A的时候，看B是否发生变化：如果B跟着也变了，说明是浅拷贝，拿人手短！（修改堆内存中的同一个值）如果B没有改变，说明是深拷贝，自食其力！（修改堆内存中的不同的值）浅拷贝只是增加了一个指针指向已存在的内存地址，深拷贝是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存</code></pre><p><strong>4.malloc/free 与 new/delete 的区别</strong></p><pre><code>1.语法上：C语言中开辟销毁空间: int *p=(int *)malloc(sizeof(int));*p=10;free(p);三步C++中: int *p=new int;   char *p=new char; int *p=new int [100];       delete p;或delete[] p;2.malloc free 是函数，标准库 在stdlib.h    new delete 是 操作符 可以被重载3.new会调用对象的构造函数，对应delete会调用对象的析构函数  malloc仅仅是分配内存，free是回收内存，不会执行构造和析构函数4.new/delete 返回的是某种数据类型指针，malloc/free 返回的是void指针</code></pre><p><strong>5.C++中struct和class的区别</strong></p><pre><code>1.默认继承权限不同，class继承默认是private继承，struct默认是public继承2.struct作为数据结构的实现体，它默认的数据访问控制是public的，  而class作为对象的实现体，它默认的成员变量访问控制是private的</code></pre><p><strong>6.C++中static静态成员变量和静态成员函数</strong></p><pre><code>1.使用static定义静态成员变量时，在类外初始化(分配内存空间)。  int A::a=1;2.静态成员变量属于整个类所有3.静态成员变量的生命期不依赖于任何对象，为程序的生命周期4.可以通过类名直接访问公有静态成员变量5.所有对象共享类的静态成员变量6.可以通过对象名访问公有静态成员变量7.静态成员变量需要在类外单独分配空间8.静态成员函数是类的一个特殊的成员函数9.静态成员函数属于整个类所有，没有this指针10.静态成员函数只能直接访问静态成员变量和静态成员函数 原因在9</code></pre><p><strong>7.关于友元的性质</strong></p><pre><code>友元不能被继承不具有传递性 B是A的友元类 C是B的 但C不一定是A的友元关系是单向的,不具有交换性,若B是A的友元类,A不一定是B的友元类(需要声明)友元得利弊：友元使得一个对象不是类成员却可以访问类的private成员 提高了运行效率破坏了类的封装性和隐藏性</code></pre><p><strong>8.智能指针  头文件 memory</strong></p><pre><code>1.auto_ptrauto_ptr&lt;数据类型&gt; ptr(new 数据类型)    C++11已舍弃为什么舍弃：auto_ptr&lt;string&gt; p1(new string(&quot;This is a string&quot;));auto_ptr&lt;string&gt; p2 = p1;//p1将所有权转让给p2，p1不再引用该字符串从而变成空指针。cout &lt;&lt; *p1 &lt;&lt; endl;//报错，此时p1已经没有所指向的内存的所有权。cout &lt;&lt; *p2 &lt;&lt; endl;使用shared_ptr时运行正常,p1,p2指向统一内存,但采用引用计数,计数值为零才会调用析构使用unique_ptr时编译出错，使用unique_ptr时，程序会在编译时出现错误2.unique_ptr (替换auto_ptr)auto_ptr有拷贝语义，拷贝后原对象无效，访问原对象会导致程序崩溃；unique_ptr禁止了拷贝语义，但提供了移动语义，即可以使用move()进行控制权限的转移unique_ptr&lt;string&gt; p1(new string(&quot;This is a string&quot;));unique_ptr&lt;string&gt; p2(p1);      //编译出错，已禁止拷贝unique_ptr&lt;string&gt; p3 = p1;     //编译出错，已禁止拷贝unique_ptr&lt;string&gt; p4 = move(p1);  //控制权限转移 p1将无权限3.shared_ptr (引用计数型的智能指针)make_shared函数   分配对象并初始化shared_ptr&lt;int&gt; p1 = make_shared&lt;int&gt;(42);shared_ptr&lt;string&gt; p2 = make_shared&lt;string&gt;(10, &#39;9&#39;);auto p3 = make_shared&lt;vector&lt;string&gt;&gt;();当进行拷贝或赋值操作时，shared_ptr都会记录有多少其他shared_ptr指向相同的对象我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象4.weak_ptrweak_ptr是为了配合shared_ptr而引入的一种智能指针，它更像是shared_ptr的一个助手而不是智能指针，因为它没有重载operator*和-&gt;，故而不具有普通指针的行为。它的最大作用在于协助shared_ptr工作weak_ptr对象的引用是弱引用</code></pre><p><strong>9.class 继承中 的 public  protected private 区别</strong></p><pre><code>子类可以调用父类的 public成员 类外部也可调用子类可以调用父类的 protected成员 类外部也不可调用子类不可以调用父类的 private成员 类外部也不可调用</code></pre><p><strong>10.public继承  protected继承 private继承 区别</strong></p><pre><code>单继承 class A :public B &#123;&#125;   形式 不用public 则默认为private多继承 class A :public B,public C... &#123;&#125;  1.只要是父类的private成员，不管什么继承方式 儿子都无法访问2.若是公有继承，儿子中的访问控制权限保持不变 类外可访问 private成员无法访问 3.若是保护继承，儿子中父亲除了private成员，都是protected成员 类外不可访问4.若是私有继承，儿子中父亲除了private成员，都是private成员 类外不可访问</code></pre><p><strong>11.C++ private和protect的区别</strong></p><pre><code>区别只在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。但对于派生类来说，保护成员的行为与公有成员相似。相同：二者都不能在类外直接访问</code></pre><p><strong>12.一个派生类继承了所有的基类方法，但下列情况除外：</strong></p><pre><code>基类的构造函数、析构函数和拷贝构造函数。基类的重载运算符。基类的友元函数。</code></pre><p><strong>13.类的赋值兼容原则   p(Parent) c(Child)</strong></p><pre><code>1.子类对象可以当作父类对象使用  (子类c可以调用父类的方法)2.子类对象可以直接赋值给父类对象  p=c;3.子类对象可以直接初始化父类对象4.父类指针可以直接指向子类对象5.父类引用可以直接引用子类对象</code></pre><p><strong>14.什么是虚继承？</strong></p><pre><code>假如有个父类 家具类 两个子类 沙发类、床类 并且每个类都有成员m代表材质那么如果现在有个类多继承于 沙发类、床类 则会有两个m 对m操作不明确因此此时对 沙发类、床类使用virtual虚继承 则会对父类相同的变量只复制一份</code></pre><p>**15.什么是虚函数？ 什么是纯虚函数？  **</p><pre><code>虚函数：因为当我们使用基类的引用或指针调用基类中定义的某个函数时，我们并不知道该函数真正的对象是什么类型(属于哪个类)，因为它可能是一个基类的对象，也可能是一个子类的对象当子类与父类有相同方法时 编译器会默认调用父类因此在父类的成员方法前加virtual ， 地址指向谁  调用谁的方法纯虚函数：纯虚函数是在基类说明的虚函数，在基类无定义，要求任何派生类都定义自己的版本纯虚函数语法：virtual 类型 函数名(参数表)=0;一个普通类继承抽象类，如果不重写纯虚函数，依然是一个抽象类抽象类的规定：抽象类只能用作其他类的基类，不能建立抽象类对象。抽象类不能用作参数类型、函数返回类型或显式转换的类型。可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性</code></pre><p><strong>16.什么是多态？ 多态产生的三个必要条件？</strong></p><pre><code>多态的定义：如果有几个相似而不完全相同的对象,有时人们要求在向它们发出同一个消息时, 它们的反应各不相同,分别执行不同的操作。这种情况就是多态现象。必要条件:1.要有继承2.要有虚函数重写3.要有父类指针或引用 指向 子类对象</code></pre><p><strong>17.动态联编与静态联编</strong></p><pre><code>联编是指一个程序模块，代码之间互相关联的过程静态联编，是程序的匹配、连接在编译阶段实现。重载函数使用静态联编动态联编，是指程序联编推迟到运行时进行。switch语句和if语句是动态联编编译器在编译过程中进行联编是静态联编  编译器生成虚方法的代码是动态联编</code></pre><p><strong>18.重载 重写 重定义 的区别？</strong></p><pre><code>重载一定是同一个作用于域下重写 重定义：是发生在两个不同的类中 一个是父类 一个是子类普通重定义：如果父类的普通成员函数，被子类重写 说是重定义虚函数重写：如果父类的虚函数，被子类重写，这个函数会发生多态</code></pre><p><strong>19.什么是野指针？</strong></p><pre><code>多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针</code></pre><p><strong>20.多态的实现原理？</strong></p><pre><code>当类中声明虚函数时，编译器会在类中生成一个虚函数表虚函数表是一个存储类成员函数指针的数据结构虚函数表时由编译器自动生成和维护的virtual成员函数会被编译器放入虚函数表存在虚函数时，每个对象中都有一个指向虚函数表的指针(vptr指针)</code></pre><p><strong>21.如何验证vptr指针的存在？</strong></p><pre><code>对两个相同的类进行sizeof 唯一的区别就是其中一个类有虚函数  会发现sizeof变大</code></pre><p><strong>22.函数模板</strong></p><pre><code>template&lt;typename T&gt; //告诉编译器 下面的是函数模板void swap(T &amp;a,T &amp;b)&#123;...&#125;1.自动类型推导 swap(a,b)//a,b为int2.显式指定类型 swap&lt;int&gt;(a,b);会优先调用普通函数，如果有更优的选择，则会调用函数模板</code></pre><p><strong>23.C/C++编译过程？</strong></p><pre><code>四个步骤：预处理、编译、汇编、链接最开始.cpp -&gt; .i   -&gt;  .s  -&gt;  .o  -&gt;  .exe预处理将头文件、宏定义替换成真正的内容，得到的仍是文本文件，但体积会大很多。编译将经过预处理之后的程序转换成特定汇编代码。汇编过程将汇编代码转换成机器码，这一步产生的文件叫做目标文件，是二进制格式。链接过程将多个目标文件以及所需的库文件(.so等)链接成最终的可执行文件。</code></pre><p><strong>24.C++四种类型转换方式</strong></p><pre><code>1.static_cast  无条件转换，静态类型转换  无运行时检查类型安全1)基类和子类间的转换：子类指针转化为父类指针安全 反过来不安全 但可以转换2)基本数据类型转换，struct int char等，不能进行无关类型转换(如非基类和子类)3)把任何类型的表达式转换为void类型4)static_cast不能去掉类型的const、volatile属性 需要用const_cast2.dynamic_cast  有条件转换，动态类型转换，运行时检查类型安全(失败返回NULL)1)安全的基类和子类之间的转换   父类指针不能转换为子类指针(不安全 指针大小)2)必须有虚函数 保持多态特性3)相同基类不同子类之间的交叉交换，但结果返回NULL3.const_cast  增加/去掉类型的const或volatile属性4.reinterpret_cast  强制类型转换1)转换的类型必须是一个指针2)最普通的用途就是在函数指针类型之间进行转换总结：去const属性用const_cast  基本类型转换用static_cast多态类之间的类型转换用dynamic_cast  不同类型的指针类型转换用reinterpret_cast</code></pre><p><strong>25.C++左值引用与右值引用</strong></p><pre><code>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的对象，即左值持久，右值短暂通过&amp;获得左值引用 int &amp; a=10(错误) int &amp;a=b(正确)const int a=10(正确) 会产生临时变量通过&amp;&amp;获得右值引用 右值引用只能绑定右值 右值引用的好处是减少右值作为参数传递时的复制开销int &amp;&amp; a=10(正确) int &amp;&amp; a=b(错误)使用move函数可以绑定到一个左值的右值引用 int &amp;&amp;a=move(b)(正确)https://blog.csdn.net/xiongya8888/article/details/83998574</code></pre><p><strong>26.智能指针出现循环引用怎么解决？</strong></p><pre><code>弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</code></pre><p><strong>27.空类的大小是多少？</strong></p><pre><code>1)C++空类的大小不为0，不同编译器设置不一样，vs设置为1；2)C++标准指出，不允许一个对象的大小为0，不同的对象不能具有相同的地址；3)带有虚函数的类大小不为1，每个对象会有vptr指向虚函数表，大小根据指针大小确定；4)C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分  配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;1. .与-&amp;gt;的区别&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.用于实际的对象  -&amp;gt;用于一个指针对象的指针
(*x).b 等价于 x-&amp;gt;b
通俗讲 
若上面使用指针申请的对象p
则调用p的方法则为 p-&amp;gt;.. 或 (*p). ... 
否则若是已经创建的实体（给了空间） 就是.
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ubuntu报错记录</title>
    <link href="http://charonxu.cn/2021/02/13/ubuntu%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    <id>http://charonxu.cn/2021/02/13/ubuntu%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/</id>
    <published>2021-02-12T16:18:12.000Z</published>
    <updated>2021-02-15T15:30:10.513Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.命令行无法打开firefox</strong></p><p>提示：<code>Error: no DISPLAY environment variable specified</code></p><p>解决方案：不应该使用root权限打开，使用普通用户权限</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1.命令行无法打开firefox&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;code&gt;Error: no DISPLAY environment variable specified&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方案：不应该使用root权限打开，使用普通用</summary>
      
    
    
    
    
    <category term="报错记录" scheme="http://charonxu.cn/tags/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令总结(四、编写Shell脚本)</title>
    <link href="http://charonxu.cn/2021/02/11/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%934/"/>
    <id>http://charonxu.cn/2021/02/11/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%934/</id>
    <published>2021-02-11T09:46:31.000Z</published>
    <updated>2021-02-15T15:30:16.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、运行Shell脚本"><a href="#一、运行Shell脚本" class="headerlink" title="一、运行Shell脚本"></a>一、运行Shell脚本</h1><h2 id="shell基础"><a href="#shell基础" class="headerlink" title="shell基础"></a>shell基础</h2><p> #! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p><p><strong>执行脚本</strong></p><p>执行脚本的两种方法：</p><a id="more"></a><pre><code>1.chmod 755 file.sh    先修改可执行权限cd到当前目录下 使用 ./file.sh   file.sh为执行的脚本名称2.通过bash调用bash file.sh如果是html文本使用firefox浏览器执行： firefox file</code></pre><p>使用echo命令进行文本时，使用的引号可以包含换行符，因此可以包含多个文本行。</p><p>使用echo -e选项可以支持\控制的字符转换</p><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><p><strong>创建变量和常量</strong></p><p>创建变量直接创建 例如： <code>foo=&quot;hello&quot;</code></p><p>运用时 需使用 <code>$+变量名</code></p><p>强制常量不发生变化 使用declare命令的-r选项</p><pre><code>declare -r foo=&quot;hello&quot;   foo后面将不会再被改变 相当于c++z中的const</code></pre><p><strong>为变量和常量赋值</strong></p><p>shell并不关心赋给变量的值的数值类型，可以通过declare命令的-i选项，强制shell将变量限制为整数类型。</p><p>在赋值时，变量名、等号和值之间不能含有空格。</p><pre><code>a=z                  将字符串z赋值给ab=&quot;a string&quot;         嵌入的空格必须用引号引起来c=&quot;a string and $b&quot;  可以被扩展到赋值语句中的其他扩展、比如变量d=$((5*7))           算术扩展e=$(ls -l foo.txt)   命令的结果f=&quot;\t\ta string\n&quot;   转义序列 比如制表符和换行符</code></pre><p>可以在一行中对多个变量赋值。</p><p>当字符变量因为上下文变得并不明确时 可以使用{}</p><h2 id="here文档"><a href="#here文档" class="headerlink" title="here文档"></a>here文档</h2><p>除了使用echo命令进行文本输出，here文档是I/O重定向的另一种形式。</p><p>工作形式如下：</p><pre><code>command &lt;&lt; tokentexttoken其中command是接收标准输入的文件名，token是用来指示嵌入文本结尾的字符串。cat &lt;&lt; _EOF_..._EOF__EOF_被选作token，表示文本的结尾 token必须单独一行出现，并且文本行的末尾没有空格</code></pre><h1 id="二、自顶向下设计"><a href="#二、自顶向下设计" class="headerlink" title="二、自顶向下设计"></a>二、自顶向下设计</h1><p><strong>shell函数</strong></p><p>shell函数有两种语法形式：</p><pre><code>function name&#123;    commands    return&#125;其中name是指这个函数的名称，commands是这个函数的一系列指令name()&#123;    commands    return&#125;</code></pre><p><strong>局部变量</strong></p><p>局部变量是通过在变量名前添加单词local来定义。</p><h1 id="三、if分支语句"><a href="#三、if分支语句" class="headerlink" title="三、if分支语句"></a>三、if分支语句</h1><h2 id="使用if"><a href="#使用if" class="headerlink" title="使用if"></a>使用if</h2><p>if语句的语法格式：</p><pre><code>if commands; then    commands[elif commands; then    commands...][else    commands]ficommands可以是一组命令 可使用；隔开会以最后一个命令的执行结果作为评判标准</code></pre><h2 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h2><p>命令在执行完毕后，会向操作系统发送一个0~255的值，用来指示命令执行成功还是失败。其中，数值0表示成功，其他的值表示执行失败。</p><p>对于每个命令可以检测退出状态：</p><pre><code>echo $?   输出0表示成功退出</code></pre><h2 id="使用test命令"><a href="#使用test命令" class="headerlink" title="使用test命令"></a>使用test命令</h2><p>test命令经常与if一起使用，会执行各种检查和比较。</p><p>有两种等价的形式：</p><pre><code>test expression  或者   [ expression ] 其中expression是一个表达式，其结果是true或false[]间必须有空格</code></pre><p>下面介绍一些表达式expression</p><p><strong>文件表达式</strong></p><p>测试文件的表达式用来评估文件的状态：</p><pre><code>表达式                          成为true的条件file1 -ef file2                file1与file2拥有相同的信息节点编号file1 -nt file2                file1比file2新file1 -ot file2                file1比file2旧-b file                        file存在并且是一个块文件-c file                        file存在并且是一个字符文件-d file                        file存在并且是一个目录-e file                        file存在-f file                        file存在并且是普通文件省略其余部分 参考p332</code></pre><p><strong>字符串表达式</strong></p><p>测试字符串的表达式用来测试字符串的操作：</p><pre><code>表达式                          成为true的条件string                         string不为空-n string                      string的长度大于0-z string                      string的长度等于0string1=string2                   string1和string2相等，双引号使用更多string1==string2string1!=string2               string1不等于string2string1&gt;string2                   在排序时，string1在string2后string1&lt;string2                   在排序时，string1在string2前</code></pre><p>在使用’&lt;’ ‘&gt;’时，必须用引号括起来，或者使用反斜杠进行转义，不然会被解释为重定向符号。</p><p><strong>整数表达式</strong></p><p>整数判断操作：</p><pre><code>表达式                          成为true的条件a -eq b                        a与b相等a -ne b                        a与b不相等a -le b                        a小于等于ba -lt b                        a小于ba -ge b                        a大于等于ba -gt b                        a大于be equal n not l less g greater </code></pre><h2 id="更现代的test命令版本"><a href="#更现代的test命令版本" class="headerlink" title="更现代的test命令版本"></a>更现代的test命令版本</h2><p>语法： <code>[[ expression ]]  expression是一个表达式 结果为true或false</code></p><p>增加了很重要的新字符串表达式：<code> string1=~regex</code></p><pre><code>x=-5if [[&quot;$x&quot;=~ ^-?[0-9]+$ ]] then...</code></pre><p>如果string1与扩展的正则表达式regex匹配，则返回true</p><p>[[]] 另一个特性是==操作符支持模式匹配：</p><pre><code>file=foo.barif [[ $file==foo.* ]];then...</code></pre><p>[[ 和 ]]之间不能有空格</p><h2 id="组合表达式"><a href="#组合表达式" class="headerlink" title="组合表达式"></a>组合表达式</h2><p>与test和[[]]命令配套的逻辑运算有三个，分别是AND，OR,NOT</p><p>逻辑操作符：</p><pre><code>operation       test                [[]]或(())AND             -a                  &amp;&amp;OR              -o                  ||NOT             !                   !</code></pre><p>由于test命令使用的所有表达式和操作符都被shell看作命令参数，不像[[]]或(())一样，因此在bash中含有特殊含义的字符如’&lt;’,’&gt;’,’(‘,’)’必须使用引号括起来或者进行转义。</p><h1 id="四、读取键盘输入"><a href="#四、读取键盘输入" class="headerlink" title="四、读取键盘输入"></a>四、读取键盘输入</h1><h2 id="read命令-从标准输入读取输入值"><a href="#read命令-从标准输入读取输入值" class="headerlink" title="read命令 从标准输入读取输入值"></a>read命令 从标准输入读取输入值</h2><p>内嵌命令read的作用是读取一行标准输入。<br>可用于读取键盘输入值或应用重定向文件读取文件的一行。</p><p>read命令的语法结构为： </p><pre><code>read [-options] [variable...]options为参数选项， variable是一到多个用于存放输入值的变量</code></pre><p>read常用的参数选项</p><pre><code>-a array             将输入值从索引为0的位置开始赋给array-d delimiter         用字符串delimiter的第一个字符标志输入的结束，而不是新的一行的开始-n num               从输入中读取num个字符，而不是一整行-p prompt             使用prompt字符串提示用户进行输入-r                   原始模式 不能将后斜线字符翻译为转义码-s                     保密模式  不在屏幕显示-t seconds           超时，在seconds秒后结束输入-u fd                从文件说明符fd读取输入，而不是从标准输入中读取</code></pre><p>如果read命令读取的值少于预期的数目，则多余的变量值为空，而输入的值数目超过预期的数量时，最后的一个变量包含了所有的多余值。</p><p>如果read命令后无变量，则会为所有输入分配一个shell变量：REPLY</p><p><strong>使用IFS间隔输入字段</strong></p><p>通常shell会间隔提供给read的内容，此行为有shell变量IFS设定，IFS设定值包含空格、制表符、换行符。</p><p>如果已知数据，不需要从键盘读取，可以使用’&lt;&lt;&lt;’操作符，象征一条嵌入字符串。</p><p>read不可重定向！</p><h1 id="五、WHILE和UNTIL循环"><a href="#五、WHILE和UNTIL循环" class="headerlink" title="五、WHILE和UNTIL循环"></a>五、WHILE和UNTIL循环</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while循环的语法结构：</p><pre><code>while [ 条件判断语句 ]    do        程序    done或者while commands; do commands; done</code></pre><p>如需跳出循环，可使用continue和break语句 ，同c语言用法</p><h2 id="until"><a href="#until" class="headerlink" title="until"></a>until</h2><p>while命令退出状态不为0时终止逊环，而until命令则刚好相反。</p><p>如果添加判断式不成立，则循环，成立则退出循环。</p><p>语法结构同while循环</p><h2 id="使用循环读取文件"><a href="#使用循环读取文件" class="headerlink" title="使用循环读取文件"></a>使用循环读取文件</h2><p>while与nutil可处理标准输入。</p><p>为了将一份文件重定向到循环中，可以在done后添加重定向符号，实例：</p><pre><code>while read a b c; do    ...done &lt; foo.txt从foo.txt文件中读取a b c 参数</code></pre><p>还可以使用管道进行读取：</p><pre><code>sort -k 1,1, -k 2n foo.txt | while read a b c; do    ...done此脚本或取sort命令的输出，但是，管道是在子shell中进行循环，所以循环终止时，循环内部新建的变量或对变量的赋值效果都会丢失。</code></pre><h1 id="六、case分支"><a href="#六、case分支" class="headerlink" title="六、case分支"></a>六、case分支</h1><p>bash的多项选择符合命令被称为case。case只能判断一种条件关系</p><p>其语法形式为：</p><pre><code>case word in        [pattern [| pattern]...) commands ;;]...esac简化case $变量名 in    1)        commands        ;;    2)        commands        ;;esac</code></pre><p><strong>模式</strong></p><p>case使用’)’字符结尾的模式。</p><p>case模式范例：</p><pre><code>a)               若关键字为a则吻合[[:alpha:]]      若关键字为单个字母则吻合???)             若关键字为三个字符则吻合*.txt)           若关键字以.txt结尾则吻合*)               任何关键字都吻合</code></pre><p><strong>多个模式的组合</strong></p><p>使用竖线作为分隔符来组合多个模式，满足其一即可。</p><h1 id="七、位置参数"><a href="#七、位置参数" class="headerlink" title="七、位置参数"></a>七、位置参数</h1><p>位置参数变量有</p><pre><code>$n            n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号例如 &#123;$10&#125;$*            这个变量代表命令行中所有的参数，把所有的参数看成一个整体$@            这个变量也代表命令中所有的参数，不过$@把每个参数区分对待$#            这个参数代表命令行中参数个数</code></pre><h1 id="八、For循环"><a href="#八、For循环" class="headerlink" title="八、For循环"></a>八、For循环</h1><p>原始的for命令语法如下：</p><pre><code>for variable [in words]; do    commandsdone其中，variable是一个在循环执行时会增加的变量名，words是一列将按顺序付给变量variable的可选项，commands部分是每次循环需要执行的命令。for i in A B C D;do    echo &quot;$i&quot;done</code></pre><p>c语言形式：</p><pre><code>for (( expression1;expression2;expression ));do    commandsdone其中expression1,expression2,expression3为算术表达式，commands是每次循环都要执行的命令。for (( i=0;i&lt;5;i++ ));do    echo $idone</code></pre><h1 id="九、字符串和数组"><a href="#九、字符串和数组" class="headerlink" title="九、字符串和数组"></a>九、字符串和数组</h1><h2 id="参数扩展"><a href="#参数扩展" class="headerlink" title="参数扩展"></a>参数扩展</h2><p><strong>基本参数</strong></p><p>普通变量用{}括起来防止shell将其与邻近文本混淆。</p><p><strong>空变量扩展的管理</strong></p><p>有的参数扩展用于处理不存在的变量和空变量。在解决缺失的位置参数和给参数赋默认值时很有用。</p><p>形式为：</p><pre><code>$&#123;parameter:-word&#125;如果参数parameter未被设定或是空参数，则其扩展为word的值，如果非空，则为parameter的值$&#123;parameter:=word&#125;如果参数parameter未被设定或是空参数，则其扩展为word的值，如果非空，则为parameter的值$&#123;parameter:?word&#125;如果参数parameter未被设定或是空参数，则会导致脚本错误并退出，并且word内容输出到标准错误，如果非空，则为parameter的值$&#123;parameter:+word&#125;如果参数parameter未被设定或是空参数，则不产生任何扩展，如果非空，则为word的值</code></pre><p><strong>返回变量名的扩展</strong></p><pre><code>$&#123;!prefix*&#125;$&#123;!prefix@&#125;该扩展返回当前以prefix开头的变量名</code></pre><p><strong>字符串操作</strong></p><pre><code>$&#123;#parameter&#125;扩展为parameter内包含的字符串长度，一般来说参数parameter是个字符串，如果参数parameter是&quot;@&quot;或&quot;#&quot;,扩展结果就是位置参数的个数。$&#123;parameter:offset&#125;$&#123;parameter:offset:length&#125;这个扩展用于提取一部分包含在参数parameter中的字符串，扩展以offset开始，直到字符串结尾，除非length指定。如果offset的值为负，默认从字符串尾部开始，注意，负值前面必须要有空格，防止与$&#123;parameter:-word&#125;混淆。$&#123;parameter#pattern&#125;$&#123;parameter##pattern&#125;根据pattern定义，去除包含在parameter中的字符串的主要部分。pattern是一个通配符模式，类似路径名的扩展。两种形式区别在于 #形式去除最短匹配，##形式去除最长匹配。$&#123;parameter%pattern&#125;$&#123;parameter%%pattern&#125;同上述扩展相同，只是此扩展从参数包含的字符串末尾去除文本。$&#123;parameter/pattern/string&#125;$&#123;parameter//pattern/string&#125;$&#123;parameter/#pattern/string&#125;$&#123;parameter/%pattern/string&#125;此扩展在parameter的内容上可执行搜索和替换，如果文本和pattern一致，则被替换为string的内容。通常形式下，只有第一个pattern被替换，在&quot;//&quot;形式下，所有的被替换，在&quot;/#&quot;形式下，要求匹配出现在字符串开头，在&quot;/%&quot;形式下，要求匹配出现在字符串末尾。/string可省略，不过匹配的内容将会被删除。</code></pre><h1 id="十、数组"><a href="#十、数组" class="headerlink" title="十、数组"></a>十、数组</h1><p><strong>创建一个数组</strong></p><p>命名数组变量同其他bash变量一样，访问时可以自动创建</p><pre><code>a[1]=foo</code></pre><p>使用declare命令也可以创建数组： </p><pre><code>declare -a a   使用declare的-a    选项创建数组名为a </code></pre><p><strong>数组赋值</strong></p><pre><code>name[subscript]=value       name是数组名，subscript是&gt;=0的整数name=(value1,value2...)     为数组多个位置赋值  从下标0开始name=([0]=1 [2]=3 [5]=6)    为特定位置赋值</code></pre><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><p><strong>输出数组的所有内容</strong></p><p>使用下标”@”和”*”访问数组的每个元素，注意使用””与不使用””遍历时不同。</p><p><strong>确定数组元素的数目</strong></p><p>使用#符号</p><p><strong>查找数组中使用的下标</strong></p><pre><code>$&#123;!array[*]&#125;$&#123;!array[@]&#125;array是数组变量名，遍历时输出数组中赋有值的位置</code></pre><p><strong>在数组的结尾增加变量</strong></p><p>使用+=符号</p><pre><code>foo=(a b c)foo+=(e d f)   </code></pre><p><strong>数组排序操作</strong></p><pre><code>a=(a b c d e)a_sorted=($(for i in &quot;$&#123;a[@]&#125;&quot;;do echo $i;done | sort))使用复制数组，遍历a数组 然后调用sort命令进行输出</code></pre><p><strong>数组的删除</strong></p><p>使用unset命令进行删除整个数组。 直接 unset 数组名</p><p>删除单个数组元素 unset ‘数组名[位置]’</p><p>对数组赋空值，只会删除数组的第一个位置，即0位置</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、运行Shell脚本&quot;&gt;&lt;a href=&quot;#一、运行Shell脚本&quot; class=&quot;headerlink&quot; title=&quot;一、运行Shell脚本&quot;&gt;&lt;/a&gt;一、运行Shell脚本&lt;/h1&gt;&lt;h2 id=&quot;shell基础&quot;&gt;&lt;a href=&quot;#shell基础&quot; class=&quot;headerlink&quot; title=&quot;shell基础&quot;&gt;&lt;/a&gt;shell基础&lt;/h2&gt;&lt;p&gt; #! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行脚本的两种方法：&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="http://charonxu.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录</title>
    <link href="http://charonxu.cn/2021/02/09/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://charonxu.cn/2021/02/09/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2021-02-09T03:13:36.000Z</published>
    <updated>2021-02-15T15:30:21.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-474-一和零"><a href="#1-474-一和零" class="headerlink" title="1. 474 一和零"></a>1. 474 一和零</h1><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ones-and-zeroes">https://leetcode-cn.com/problems/ones-and-zeroes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：简化后将每个字符串0，1记录，就是二维状态下的01背包。</strong></p><pre><code>class Solution &#123;public:    int f[110][110];    int v[610], w[610];    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;        int mx = 0;        for (int i = 0; i &lt; strs.size(); i++)        &#123;            int cnt0 = 0, cnt1 = 0;            for (int j = 0; j &lt; strs[i].size(); j++)            &#123;                if (strs[i][j] == &#39;0&#39;) cnt0++;                else cnt1++;            &#125;            v[i] = cnt0, w[i] = cnt1;        &#125;        for (int i = 0; i &lt; strs.size(); i++)        &#123;            for (int j = m; j &gt;= v[i]; j--)            &#123;                for (int k = n; k &gt;= w[i]; k--)                &#123;                    f[j][k] = max(f[j - v[i]][k - w[i]] + 1, f[j][k]);                &#125;            &#125;        &#125;        return f[m][n];    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-474-一和零&quot;&gt;&lt;a href=&quot;#1-474-一和零&quot; class=&quot;headerlink&quot; title=&quot;1. 474 一和零&quot;&gt;&lt;/a&gt;1. 474 一和零&lt;/h1&gt;&lt;p&gt;给你一个二进制字符串数组 strs 和两个整数 m 和 n 。&lt;/p&gt;
&lt;p&gt;请</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://charonxu.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令总结(三、常见任务和主要工具)</title>
    <link href="http://charonxu.cn/2021/02/01/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%933/"/>
    <id>http://charonxu.cn/2021/02/01/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%933/</id>
    <published>2021-02-01T15:15:55.000Z</published>
    <updated>2021-02-15T15:29:47.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、软件包管理"><a href="#一、软件包管理" class="headerlink" title="一、软件包管理"></a>一、软件包管理</h1><p>下面各命令都以Debian类为例，包含ubuntu</p><p>Debian类的系统  使用的低级工具为dpkg      高级工具为apt-get、aptitude</p><h2 id="常见的软件包管理任务"><a href="#常见的软件包管理任务" class="headerlink" title="常见的软件包管理任务"></a>常见的软件包管理任务</h2><p><strong>在库里面查找软件包</strong></p><pre><code>apt-get updateapt-cache search search_string       </code></pre><a id="more"></a><p><strong>安装库中的软件包</strong></p><pre><code>apt-get updateapt-get install package_name    package_name 是软件包名称</code></pre><p><strong>更新库中的软件包</strong></p><pre><code>apt-get updateapt-get upgrade</code></pre><p><strong>安装软件包文件中的软件包</strong></p><pre><code>dpkg --install package_file     package_file 是软件包文件</code></pre><p><strong>更新软件包文件中的软件包</strong></p><pre><code>dpkg --install package_file</code></pre><p><strong>删除软件包</strong></p><pre><code>apt-get remove package_name</code></pre><p><strong>列出已安装的软件包列表</strong></p><pre><code>dpkg --list   或   dpkg -l</code></pre><p><strong>判断软件包是否安装</strong></p><pre><code>dpkg --status package_name</code></pre><p><strong>显示已安装软件包的相关信息</strong></p><pre><code>apt-cache show package_name</code></pre><p><strong>查看某具体文件由哪个软件包安装得到</strong></p><pre><code>dpkg --search file_name</code></pre><h1 id="二、存储介质"><a href="#二、存储介质" class="headerlink" title="二、存储介质"></a>二、存储介质</h1><h2 id="挂载、卸载存储设备"><a href="#挂载、卸载存储设备" class="headerlink" title="挂载、卸载存储设备"></a>挂载、卸载存储设备</h2><p><strong>查看已挂载的文件系统列表</strong></p><p>mount命令 用于文件系统挂载 ，不带参数时 该命令会调出目前已经挂载的文件系统列表。</p><p>会显示    <code>文件系统名称  on 路径 类型名 </code></p><p>umount命令可卸载设备 使用为 umount+路径</p><p>使用-t参数可以指定文件系统类型 使用方式为： </p><pre><code>mount -t 类型 文件系统名 挂载在何处</code></pre><p><strong>确定设备名称</strong></p><p>所有设备所在的目录为 /dev 目录</p><p>Linux存储设备名称：</p><pre><code>/dev/fd*             软盘驱动器/dev/hd*             较旧系统上的IDE硬盘/dev/lp*             打印机设备/dev/sd*             SCSI硬盘/dev/sr*             光驱</code></pre><h2 id="创建新的文件系统"><a href="#创建新的文件系统" class="headerlink" title="创建新的文件系统"></a>创建新的文件系统</h2><p><strong>mkfs命令 创建新的文件系统</strong></p><pre><code>使用用例：sudo mkfs -t ext3 /dev/sdb1创建一个类型为ext3的文件系统,位置在 /dev/sdb1</code></pre><h1 id="三、网络命令"><a href="#三、网络命令" class="headerlink" title="三、网络命令"></a>三、网络命令</h1><h2 id="检查、检测网络"><a href="#检查、检测网络" class="headerlink" title="检查、检测网络"></a>检查、检测网络</h2><p><strong>ping命令 向网络主机发送特殊数据包</strong></p><p>常用于测试网络连通性</p><pre><code>ping [参数] [ip地址]            可不加参数相关参数:  -c 指定发送次数   例如:  ping -c 10 charonxu.cn  向网站发送10次数据包使用 ctrl+C 终止程序 如果数据包丢失0% 则表示网络运行正常  默认传送数据时间间隔为1s</code></pre><p><strong>tracerouer命令 跟踪网络数据包的传输路径</strong></p><p>会显示文件通过网络从本地系统传输到指定主机过程中所有停靠点的列表</p><pre><code>traceroute [网址]</code></pre><p>在列表中会列出主机名、IP地址以及运行状态信息  包含文件从本地系统到路由器3次往返时间</p><p>对于不提供身份信息的路由器 会用星号代替</p><p><strong>netstat命令  检查网络设置及相关统计数据 （显示网络相关信息）</strong></p><pre><code>netstat [参数]相关参数: -t TCP协议   -u UDP协议   -l 监听   -r 路由  -n 显示IP地址和端口号 常用例子: netstat -tlun  查看本机监听的端口   netstat -an 查看本机所有的网络连接          netstat -rn 查看本机路由表</code></pre><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p><strong>who命令 查看当前在线用户</strong></p><pre><code>who 无参数          显示的是当前机器下在线人数</code></pre><p><strong>write命令 给其他在线用户发信息</strong></p><pre><code>write [用户名]      然后换行输入发送的信息  ctrl+C结束</code></pre><p><strong>wall命令 给所有在线用户发送广播信息</strong></p><pre><code>wall [message]是write all 的缩写</code></pre><p><strong>mail命令 查看电子邮件</strong></p><pre><code>mail [用户]        换行输入内容</code></pre><p><strong>lastlog 检查某特定用户上次登陆的时间</strong></p><pre><code>last -u [用户UID]</code></pre><h2 id="通过网络传输文件"><a href="#通过网络传输文件" class="headerlink" title="通过网络传输文件"></a>通过网络传输文件</h2><p><strong>ftp命令  采用FTP（文件传输协议）传输文件</strong></p><p>ftp是不安全的协议，因为它以明文的方式传送账户名以及密码。<br>这意味着信息未进行加密，任何人都可以看到。</p><p>因此，所有使用FTP协议进行网络文件传输都是由匿名FTP服务器处理的。</p><p>ftp命令实例:</p><pre><code>ftp fileserver      启动ftp程序，建立与FTP服务器fileserver的连接之后会提示 使用用户名何用户密码登录 某些服务器接收空密码 某些服务器需要以邮件地址的格式之后就可以进行操作</code></pre><p><strong>lftp命令 更好的ftp</strong></p><p>与传统的ftp程序功能类似但有很多额外的便利功能,包括多协议支持(HTTP)，下载失败时自动重新尝试、后台进程支持、</p><p>Tab键完成文件名输入等许多其他的功能。<br><strong>wget命令 非交互式网络下载工具</strong></p><p>该命令既可以从网站上下载内容 也可以从FTP站点下载。</p><pre><code>wget [参数] [URL]参数选项很多 支持递归下载、后台文件下载以及继续下载被下载的文件等操作 可使用man手册页查看</code></pre><h2 id="与远程主机的安全通信"><a href="#与远程主机的安全通信" class="headerlink" title="与远程主机的安全通信"></a>与远程主机的安全通信</h2><p><strong>ssh命令 安全登录远程计算机</strong></p><p>ssh协议是为了解决明文传送的问题，解决了与远程主机进行安全通信的两个基本问题：</p><p>1.该协议能验证远程主机的身分是否真实，避免中间人攻击。</p><p>2.该协议将本机与远程主机之间的通信内容全部加密。</p><p>使用ssh客户端程序与远程主机remote-sys建立连接举例：</p><pre><code>ssh remote-sys      首次尝试连接会提示不能确定远程主机真实性的消息     一旦建立连接 会提示用户输入密码输入密码后会进入到远程shell对话   使用exit命令可断开连接   恢复本地shell对话使用非本地系统的用户名也可以登录 例如远程系统上有bob账户 可使用如下命令登录：ssh bob@remote-sysssh命令除了能开启远程系统上的shell对话外，也能执行单个简单命令：ssh remote-sys free    在远程主机上执行free命令 获得可用内存使用简单命令时想把结果输出到本地系统文件中：   ssh remote-sys 'ls *' > out.txt若是想直接输出到远程系统的文件中应该将重定义符号和文件名同置于引号中： ssh remote-sys 'ls * > out.txt' </code></pre><p><strong>scp和sftp命令 安全传输文件</strong></p><p>scp命令与cp命令类似，差别在于scp命令的源或目的地路径前面多个远程主机号和冒号。</p><pre><code>使用scp命令在远程主机home目录下将out.txt文件复制到本地系统中的当前目录下操作如下：    scp remote-sys:out.txt .如果不是使用本地用户名登录，则需要加用户名前缀：    scp bob@remote-sys:out.txt .</code></pre><p>sftp是ftp的安全版本 sftp使用SSH加密隧道传输信息 而不是以明文方式传输。</p><p>sftp不需要远程主机上运行FTP服务器，仅需要SSH服务器，这意味着任何与SSH客户端连接的远程机器都可以当作FTP服务器使用。</p><hr><h1 id="四、文件搜索"><a href="#四、文件搜索" class="headerlink" title="四、文件搜索"></a>四、文件搜索</h1><h2 id="locate命令-较简单的方式查找文件"><a href="#locate命令-较简单的方式查找文件" class="headerlink" title="locate命令 较简单的方式查找文件"></a>locate命令 较简单的方式查找文件</h2><p>查找目录名以zip开头的文件</p><pre><code>locate ziplocate bin/zip      其中bin限制了路径，查找bin路径下以zip开头的文件</code></pre><p> locate 与 find 不同: find 是去硬盘找，locate 只在 /var/lib/slocate 资料库中找。</p><p>locate 的速度比 find 快，它并不是真的查找，而是查数据库，一般文件数据库在 /var/lib/slocate/slocate.db 中，所以 locate 的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库 ，命令为： <code>updatedb</code></p><h2 id="find命令-较复杂的方式查找文件"><a href="#find命令-较复杂的方式查找文件" class="headerlink" title="find命令 较复杂的方式查找文件"></a>find命令 较复杂的方式查找文件</h2><h3 id="test选项"><a href="#test选项" class="headerlink" title="test选项"></a>test选项</h3><p>语法: find [搜索范围] [匹配条件]</p><p><strong>根据文件名搜索</strong></p><pre><code>find / -name file_name   / 表示范围，全局范围下  file_name表示搜索的文件名称find ~ -name 's.txt'  例子</code></pre><p><strong>根据文件大小搜索</strong></p><pre><code>find / -size +204800   查询大小大于100M的文件其中 +n表示大于n -n表示小于n n等于n  在linux系统中   一个数据块=0.5K 100MB=204800数据块是linux存储文件的单位</code></pre><p><strong>根据时间搜索</strong></p><pre><code>find / -amin n    查询当前目录下过去n分钟被读取过的文件-amin n 在过去n分钟被读取过    -cmin n 在过去n分钟被修改过-atime n 在过去n天被读取过     -ctime n 在过去n天被修改过   这四个方式使用同上 n支持+-=</code></pre><p><strong>根据文件类型搜索</strong></p><pre><code>find / -type file_type file_name其中file_type表示文件类型 常用的有:  f:一般文件  d:目录  l:软链接文件  s:socket</code></pre><p><strong>多个参数选项同用</strong></p><pre><code>find ~ -type f -name "*.JPG" -size +1M | wc -l输出文件种类为普通文件 名字以JPG为后缀 大小大于1M 的文件数量</code></pre><p><strong>find命令的逻辑操作符</strong> </p><pre><code> -a 两个条件同时满足     -o 两个条件满足任意一个即可   () 多个检测条件时 默认情况下 find从左向右 扰乱默认顺序</code></pre><h3 id="action选项"><a href="#action选项" class="headerlink" title="action选项"></a>action选项</h3><p>预定义的find命令操作：</p><pre><code>-delete      删除匹配的文件-ls          对匹配的文件进行ls操作-print       将匹配的文件的全路径以默认形式输出 是默认操作-quit        一旦匹配成功就退出</code></pre><p>参数需要加在命令的最后面    注意与test选项的前后关系</p><p><strong>用户自定义操作</strong></p><pre><code>将find查找的文件直接进行某种操作 find / -name file_name -exec ls -l &#123;&#125; \;其中 / 表示路径   file_name 查找文件名    ls -l  进行什么操作   其它东西格式固定将 -exec 换成 -ok 则在操作每个文件时都会询问是否进行操作</code></pre><h3 id="option选项"><a href="#option选项" class="headerlink" title="option选项"></a>option选项</h3><p>find命令的常用option选项：</p><pre><code>-depth    引导find程序处理目录前先处理目录内的文件，使用-delete操作时 会自动调用-maxdepth levels   当执行测试条件行为时，设置find程序陷入目录数的最大级别数-mindepth levels   最小级别数-mount    引导find程序不去遍历挂在在其他文件系统上的目录-noleaf   优化搜索 </code></pre><hr><h1 id="五、归档与备份"><a href="#五、归档与备份" class="headerlink" title="五、归档与备份"></a>五、归档与备份</h1><h2 id="文件压缩与归档"><a href="#文件压缩与归档" class="headerlink" title="文件压缩与归档"></a>文件压缩与归档</h2><p><strong>gzip命令 文件压缩与解压缩</strong></p><pre><code>gzip file_name     压缩文件file_namegunzip file_name  或者  gzip -d file_name     解压缩文件注意: 在linux系统下gzip命令只能压缩文件 不可以压缩目录   并且   压缩后文件消失 不保留原文件</code></pre><p>gzip参数选项：</p><pre><code>-c    将输出内容写到标准输出端口并且保留原有文件-d    解压缩 加上此选项 gzip命令类似于 gunzip-f    强制压缩 即便原文件的压缩版本已存在 -h    显示有用信息  --help-l    列出所有压缩文件的压缩统计-r    递归压缩-t    检验压缩文件的完整性-v    压缩时显示详细信息-number   设定压缩级别  number从1-9 速度依次变慢 压缩比变大</code></pre><p><strong>tar命令 打包压缩目录</strong>  </p><pre><code>tar 选项[-cvfz] 压缩后目录名 需要压缩的目录参数含义:  -c 打包   -v 显示详细信息   -f 指定文件名   -z 打包同时压缩 如果不使用 -z 命令 则是打包目录  需再使用 gzip 命令进行压缩tar命令解压缩语法:  tar -zxvf 压缩文件名参数含义:  -x 解包   -v 显示详细信息   -f 指定文件名   -z 解压缩</code></pre><p><strong>zip命令 压缩文件或目录</strong></p><pre><code>zip 压缩后文件名 需要压缩文件名    使用 -r 参数 可以压缩目录解压缩:    unzip 压缩后文件名zip 可以保留原文件</code></pre><p><strong>bzip2命令 压缩文件(牺牲速度换取高压缩比)</strong></p><pre><code>bzip2 file_name   添加参数 -k 可以保留原文件bunzip2   解压缩文件    添加参数 -k 保留原压缩文件</code></pre><h2 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h2><p><strong>rsync命令 远程文件、目录的同步</strong></p><p>rsync命令调用方式： <code>rsync options source destination</code></p><p>其中sourse与destination必须有一个本地文件，不允许远程系统相互复制。</p><p>常用参数options：</p><pre><code>-a     用于归档  进行递归归档并保存文件属性-v     详细输出</code></pre><h1 id="六、正则表达式"><a href="#六、正则表达式" class="headerlink" title="六、正则表达式"></a>六、正则表达式</h1><h2 id="grep命令-文本搜索"><a href="#grep命令-文本搜索" class="headerlink" title="grep命令 文本搜索"></a>grep命令 文本搜索</h2><pre><code>grep [option] regex [file...]        字符串regex代表某个正则表达式  [file...]表示搜索文件名 可使用通配符进行多文件搜索参数选项：-i    忽略大小写-v    不匹配，输出不匹配的所有行-c    输出匹配项的数目-l    输出匹配项文件名而不是输出匹配行本身-L    与-l类似，单输出的是不包含匹配项的文件名-n    在每个匹配行前面加上该行在文件内的行号-h    进行多文件搜索时，抑制文件名输出</code></pre><p>举例：</p><pre><code>grep abc list*.txt   对list*.txt进行多文件搜索文本abc 输出匹配行grep -l abc list*.txt  同上 但输出的是文件名grep -L abc list*.txt  同上 但输出的是不匹配文件的文件名</code></pre><h2 id="元字符和文字"><a href="#元字符和文字" class="headerlink" title="元字符和文字"></a>元字符和文字</h2><p>正则表达式的元字符包括下列字符：</p><pre><code>^ $ . [ ] &#123; &#125; - ? * + ( ) | \</code></pre><p>其他字符被当作文字字符，但在极少情况下，\ 字符用来创建元序列，以及用来对元字符进行转义</p><h2 id="任意字符"><a href="#任意字符" class="headerlink" title="任意字符"></a>任意字符</h2><p>匹配任意字符的元字符 <code>.</code><br>例如使用命令查询     <code>grep &#39;.zip&#39; dirlist.txt</code></p><p>会查询包含zip的长度大于等于4的行 即<code>·</code>不能代替空字符。</p><h2 id="锚"><a href="#锚" class="headerlink" title="锚"></a>锚</h2><p>插入符(^)和美元符号($)在正则表达式中被当作锚，也就是说正则表达式只与行的开头(^)或末尾($)进行匹配。</p><pre><code>grep -h &#39;^zip&#39; dirlist.txtzipzipcloakzipgrep显示的行都是以zip开头grep -h &#39;zip$&#39; dirlist.txtasdazipsdazip显示的行都是以zip结尾grep -h &#39;^zip$&#39; dirlist.txtzip显示行就是zip如果使用正则表达式&#39;^$&#39; ，则匹配的应该是空行</code></pre><h2 id="中括号表达式和字符类"><a href="#中括号表达式和字符类" class="headerlink" title="中括号表达式和字符类"></a>中括号表达式和字符类</h2><p>中括号除了用于匹配正则表达式中给定位置的定义字符外，还可用于匹配指定字符集中的单个字符。</p><pre><code>grep -h [bg]zip dirlist.txtbzipgzip</code></pre><p>某些字符在[] 中巨有不同的含义，^在中括号中表示否定，-表示字符范围。</p><p><strong>否定</strong></p><p>如果中括号中的第一个字符是插入符(^),则表示剩下的字符被当作不应该在指定位置出现的字符集。</p><pre><code>grep -h&#39;[^bg]zip&#39; dirlist.txtbunzipgunzipunzip并且[]位置只能限制一个字符</code></pre><p><strong>传统字符范围</strong></p><pre><code>查找首字母为大写的行grep -h &#39;^[A-Z]&#39; dirlist.txt可支持多个范围grep -h &#39;^[A-Za-z0-9]&#39; dirtlist.txt取消连字符的特殊用法 作为普通的字符grep -h &#39;[-AZ]&#39; dirtlist.txt    只作为单一字符使用</code></pre><p><strong>POSIX字符类</strong></p><pre><code>[:alnum:]           字母字符和数字字符 (a-z A-Z 0-9)[:word:]            同上 多了个下划线&#39;_&#39;[:alpha:]           字母字符[:blank:]           包括空格和制表符[:cntrl:]           ASCII控制码 0-31 127[:digit:]           数字字符[:graph:]           可见字符  33-126[:lower:]           小写字母[:punct:]           标点符号字符  #￥%……&amp;*等[:print:]           可打印字符[:space:]           空白字符  空格符、制表符、回车符、换行符等[:upper:]           大写字母[:xdight:]          用于表示十六进制字母  0-9 A-F a-f</code></pre><p><strong>或选项</strong></p><p>或选项，用元字符’|’表示</p><p>grep 中 -E 选项 用于延伸正则表达式</p><pre><code>echo &#39;AAA&#39; | grep -E &#39;AAA|BBB&#39;    使用引号防止当作管道操作使用对于文本结果匹配字符串AAA或BBBecho -E &#39;^(zip|gz|bz)&#39; dirlisst.txt使用()将或选项的左右元素与其他符号分开</code></pre><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p><strong>？ 匹配某元素0次或1次</strong></p><p>匹配的是前面的一个字符</p><pre><code>grep -E &#39;\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]$&#39;(555) 123-4567555 123-4567(与)可出现0次或以1次</code></pre><p><strong>* 匹配某元素多次或零次</strong></p><p>匹配上一个字符任意次        必须保持同上        用法同？类似</p><p><strong>+ 匹配某元素一次或多次</strong></p><p>+元字符与*元字符很相似，但是+元字符要求前面的元素至少出现一次</p><p><strong>{} 以指定次数匹配某元素</strong></p><p>指定匹配次数</p><pre><code>&#123;n&#125;         前面的元素恰好出现n次匹配&#123;n,m&#125;       前面的元素出现次数在n~m之间&#123;n,&#125;        前面的元素出现次数超过n次则匹配&#123;,m&#125;        前面的元素不超过m次则匹配</code></pre><h1 id="七、文本处理"><a href="#七、文本处理" class="headerlink" title="七、文本处理"></a>七、文本处理</h1><p>温故知新</p><h2 id="cat命令-进行文件之间的拼接并且输出到标准输出"><a href="#cat命令-进行文件之间的拼接并且输出到标准输出" class="headerlink" title="cat命令 进行文件之间的拼接并且输出到标准输出"></a>cat命令 进行文件之间的拼接并且输出到标准输出</h2><pre><code>cat &gt; out.txt准备向out.txt文件输入内容 以 Ctrl+D 表示结束使用-A选项可以显示文本内容：cat -A out.txt显示文本内容 其中&quot;^I&quot;表示制表符  末尾出现&quot;$&quot;表示末尾空格cat最常用选项：-n 对行编号          -s 禁止输出多个空白行</code></pre><h2 id="sort命令-对文本进行排序"><a href="#sort命令-对文本进行排序" class="headerlink" title="sort命令 对文本进行排序"></a>sort命令 对文本进行排序</h2><pre><code>sort &gt; out.txt       输入三行文本  Ctrl+D 结束baccat out.txt          查看文本 已经排好序abc</code></pre><p>sort支持多文件排序</p><pre><code>sort file1 file2 fil3 &gt; final.txt   将结果融合为单个文本</code></pre><p>常见的sort选项参数：</p><pre><code>-b       默认情况下会从行的开头字符排序，此选项可忽略行开头空格，从第一个非空格字符开始-f       排序时不区分字符大小写-n       基于字符串的长度进行排序-f       逆序排序  将结果按照逆序结果输出-o       将排序结果输出到文件而不是标准输出-k       -key=[field1,field2]间的字符进行排序 对第几个字段进行排序-r       逆序排列 </code></pre><p>举例：</p><pre><code>sort -k 3.7nbr -k 3.1nbr out.txt上述例子表示sort支持多参数，3.7表示按第三个字段的第七个字符排序 nbr指参数</code></pre><h2 id="uniq命令-通知或省略重复的行"><a href="#uniq命令-通知或省略重复的行" class="headerlink" title="uniq命令 通知或省略重复的行"></a>uniq命令 通知或省略重复的行</h2><p>重复的行是相对于上一行而言，不是整个文本</p><p>常见的uniq选项参数：</p><pre><code>-c       输出重复行列表，并且在行的前面加上其出现的次数-d       只输出重复行，而不包括单独行-fn      忽略每行前n个字段 字段默认以空格分开-i       行与行之间比较时忽略大小写-sn      跳过每行前n个字符-u       仅输出不重复的行 该选项时默认的</code></pre><h2 id="切片和切块"><a href="#切片和切块" class="headerlink" title="切片和切块"></a>切片和切块</h2><p><strong>cut命令 删除文本行中的部分内容</strong></p><p>常见的cut选项参数：</p><pre><code>-c char_list      从文本行中提取char_list定义的部分内容，此列表可能包含多个：分割的范围   -c 7-10 提取第7-10字符-f field_list     从文本行中提取field_list定义的一个或多个字段，此列表可能包含多个：分割的范围   -f 3 即表示提取第三个字段-d delim_char     指定-f后，使用delim_char作为字符分界符，默认时，必须使用单个Tab隔开   -d &#39;:&#39; 将：作为分界符--complement      从文本中提取整行，除了那些由-c和/或-f指定的部分</code></pre><p><strong>paste命令 合并文本行</strong></p><p>向文件中增加一个或多个文本列</p><p>举例：<code>paste a.txt b.txt </code>   将a的文本按顺序加入b的列中</p><p><strong>join命令 连接两文件中具体相同字段的行</strong></p><p>如果两个文件具有相同的字段，就会将两个文本连接 。</p><p>文件必须实现依据共有关键字段排序，而且默认使用空格作为分界符。</p><h2 id="文本比较"><a href="#文本比较" class="headerlink" title="文本比较"></a>文本比较</h2><p><strong>comm命令 逐行比较已排序文本</strong></p><p>comm命令对结果会返回三列标准输出，第一列显示的是第一个文件独有的行，第二列显示的是第二个文件独有的行，第三列显示的是两个文件所共有的行(即相同的行内容)。</p><p>comm命令支持参数 -n n的值为1，2，3，表示可省略第几列的内容 </p><p>comm -2 就是省略第二列  comm -12 就是省略第12列</p><p><strong>diff命令 逐行比较文件</strong></p><pre><code>diff a.txt b.txt  对比a b文本</code></pre><p>该命令会对两个文本进行逐行对比 然后标准输出如何修改才能使两个文本相同</p><p>diff改变命令：</p><pre><code>r1ar2      将第二个文件中r2位置的行添加到第一个文件中的r1位置处r1cr2      用第二个文件r2位置的行替换第一个文件r1位置的行r1dr2      删除第一个文件r1处的行，并且删除的内容作为第二个文件r2位置的行</code></pre><p>标准输出中每个改变命令后会说明如何修改，其中’&lt;’表示删除行的内容  ‘&gt;’表示添加行的内容</p><p>使用 -c 参数 则会使用上下文格式的输出结果<br>例如有两个文本如下：</p><pre><code>a.txt  b.txta          bb          cc          dd          e</code></pre><p>使用 -c 参数后：</p><pre><code>diff -c a.txt b.txt*** a.txt    2021-02-07 22:50:23.254269194 +0800--- b.txt    2021-02-07 22:50:34.082966633 +0800****************** 1,4 ****- a  b  c  d--- 1,4 ----  b  c  d+ e</code></pre><p>diff上下文格式差异标识符：</p><pre><code>(无)      该行表示上下文文本，表示两个文件共有的行-         缺少的行，指此行在第一个文件中出现，第二个文件没有+         多余的行，指此行在第二个文件中出现，第一个文件没有!         改变的行，两个版本的行内容都会显示出来，每一个都会出现在差异组中相应的部分</code></pre><p>使用 -u 参数 则会使用统一格式的输出结果</p><pre><code>diff -u a.txt b.txt--- a.txt    2021-02-07 22:50:23.254269194 +0800+++ b.txt    2021-02-07 22:50:34.082966633 +0800@@ -1,4 +1,4 @@     表示两文件各自的行数-a b c d+e</code></pre><p>diff统一格式差异标识符：</p><pre><code>(无)        两个文件共有的行           可以理解为无变动-           相对于第二个文件而言，没有的行    可以理解为删除该行+           相对于第一个文件多余的行          可以理解为增加此行</code></pre><h2 id="非交互式文本编辑"><a href="#非交互式文本编辑" class="headerlink" title="非交互式文本编辑"></a>非交互式文本编辑</h2><p><strong>tr命令 替换或删除字符</strong></p><p>tr可对标准输入进行操作并且将结果以标准输出的形式输出。</p><p>字符集的形式包括 枚举列表(ABCD)、字符范围(A-Z)、POSIX字符类([:lower:])</p><p>将小写字母替换为大写字母：  <code>echo &#39;lower&#39; | a-z A-Z</code></p><p>使用tr命令可删除字符：<code>tr -d &#39;\r&#39; &lt;dos_file&gt; unix_file</code> </p><p>其中dos_file是需要操作的文件，unix_file是转化的结果文件(会创建) &lt;…&gt; 是固定格式</p><p>其他参数：    <code>-s   删除重复出现的字符 ，必须是相邻的  并且使用多位于标准输入输出中</code></p><p><strong>sed命令 用于文本过滤和转换的流编辑器</strong></p><p>sed是sream editor流式编辑器，可以对文本流、指定文件集或标准输入进行文本编辑。</p><p>sed命令功能强大，异常复杂，所以并未涉及到所有语法。</p><pre><code>echo &#39;front&#39; | sed &#39;s/front/back&#39;backecho &#39;front&#39; | sed &#39;s_front_back&#39;back由上述两个指令可知，sed中，替换命令可由字母s代替，其后紧跟被替换字符以及替换成何字符。sed支持任意字符作为分界符，紧跟&#39;s&#39;后变是分界符。指定行进行替换echo &#39;front&#39; | sed &#39;1s/front/back&#39;     只对输入流的第一行进行替换echo &#39;front&#39; | sed &#39;2s/front/back&#39;     只对输入流的第二行进行替换</code></pre><p>此替换又名地址表示法 在’s’前加参数，常用的地址表示法有：</p><pre><code>n             n是正整数 表示行号$             表示最后一行addr1,addr2   表示行范围 对addr1至addr2的行进行替换first~step    表示从first行开始，间隔为step行进行替换addr1,+n      表示从addr1行开始，向后n行进行替换addr!         除了addr外的所有行 addr可以用上面的任意形式替换</code></pre><p>使用sed命令的特点，就是替换字符串后面可以紧跟可选择标识符，最重要的就是-g，该标志表示对所有匹配项进行替换操作，而不是只对第一个匹配项替换。</p><pre><code>echo &quot;aaabbbccc&quot; | sed &#39;s/b/B&#39;      对第一个匹配项进行替换aaaBbbcccecho &quot;aaabbbccc&quot; | sed &#39;s/b/B/g&#39;    对所有匹配项进行替换aaaBBBccc</code></pre><p><strong>aspell命令 交互式拼写检查工具</strong></p><pre><code>aspell check filename   检查文件中的拼写错误</code></pre><h1 id="八、格式化输出"><a href="#八、格式化输出" class="headerlink" title="八、格式化输出"></a>八、格式化输出</h1><h2 id="简单的格式化工具"><a href="#简单的格式化工具" class="headerlink" title="简单的格式化工具"></a>简单的格式化工具</h2><p><strong>nl命令 对行进行标号</strong></p><p>nl与cat-n 相似，都能显示行号</p><pre><code>nl out.txt    标准输出out.txt文件内容，并显示行号</code></pre><p>nl既支持多文件名作为命令行参数，也支持标准输入。</p><p>nl标号时支持逻辑页的概念，逻辑页可分解为标题、正文、页脚</p><p>三个部分表示如下：</p><pre><code>\:\:\:        逻辑页页眉开头\:\:          逻辑页正文开头\:            逻辑页页尾开头</code></pre><p>常用的nl参数选项：</p><pre><code>-b style   按照style格式对正文进行编号，style选项如下：           a 对每行编号   t 仅对非空白行编号，默认的   n 不对任何行标号   pregexp 只对与正则表达式匹配的行编号 -f style   按照style格式对页脚进行编号-h style   按照style格式对标题进行编号-p         在每个逻辑页开始不在进行页编码重置-s string  在每行行号后增肌string作为分界符，默认是Tab-v number  将每个逻辑页的第一个行号设为number,默认是1</code></pre><p><strong>fold命令 将文本中的行长度设定为指定长度</strong></p><pre><code>使用-w选项定长将文件分割：fold -w 3 out.txt   将文件以每行三个字符的长度分割  默认是80个字符宽fold断行时不会考虑单词边界，使用-s选项，在到达指定长度的前的最后一个空格处将文本断开fold -w 3 out.txt -s</code></pre><p><strong>fmt命令 简单的文本格式化工具</strong></p><p>使用fmt命令将文件定长格式化：<code>fmt -w 50 out.txt</code>,每行按50长度分割</p><p>默认情况下，空白行、单词之间的空格和缩进都保留在输出结果中，不同缩进量的连续输入行并不进行拼接；制表符会在输入中扩展并直接输出。</p><p>fmt的常用参数选项：</p><pre><code>-c              保留前两行的缩进，随后的行斗鱼第二行的缩进对齐-p strnig       只格式化以string为开头的行-s              将会只根据指定的列宽截断行，断航不会与其他行合并-u              字符间隔统一，字符间隔一个空格，句子间隔两个空格-w width        指定每行文本不超过width个字符 默认值75</code></pre><p><strong>pr命令 格式化打印文本</strong></p><p>pr命令可用于给文本标页码，打印文本时，每页的顶部与尾部都会有几行空格。</p><pre><code>pr -l 15 -w 50 out.txt每页15行，每行50个字符</code></pre><p><strong>printf命令 格式化并打包数据</strong></p><p>用法：</p><pre><code>printf &quot;format&quot; argumentprintf &quot;I&#39;m a %s\n&quot; student输出 I&#39;m a student</code></pre><p>printf的数据类型指定符参照c语言 ，d 十进制整数 f 浮点数 o 八进制  x 整数格式化为十六进制 小写  X 大写</p><h1 id="九、打印"><a href="#九、打印" class="headerlink" title="九、打印"></a>九、打印</h1><h2 id="准备打印文件"><a href="#准备打印文件" class="headerlink" title="准备打印文件"></a>准备打印文件</h2><p><strong>pr命令 将文本文件转换为打印文件</strong></p><p>pr命令可用于调整文本以适应特定纸张的大小，并且可自主选择页眉和页边距。</p><pre><code>ls /usr/bin | pr -3 -w 65 | head列出/use/bin目录下的文件 用pr命令 格式化为分页、三列的输出</code></pre><p>常见的pr参数选项</p><pre><code>+first[:last]       输入一个从first开始以last结束的页范围-colnums            将页的内容分为指定的colnums列-a                  默认情况下，多列输出是垂直列出的，增加-a选项便是水平输出-d                  隔行打印输出-n                     对行进行编号</code></pre><h2 id="向打印机发送打印任务"><a href="#向打印机发送打印任务" class="headerlink" title="向打印机发送打印任务"></a>向打印机发送打印任务</h2><p><strong>lpr命令 打印文件(Berkeley类型)</strong></p><p>既支持标准输入，也可以用于管道传输</p><p>将文件发送至不同的打印机，使用-P选项，实例：</p><pre><code>lpr -P printer_name         print_name表示目标打印机名称</code></pre><p>查看系统打印机列表</p><pre><code>lpstat -a</code></pre><p>常见的lpr参数选项</p><pre><code>-# number           打印number份副本-p                  每一页都包括日期、时间、工作名称和页码的页眉用阴影打印出来-P printer          指定用于打印输出的打印机名-r                     打印结束后删除文件</code></pre><p><strong>lp命令 打印文件(System V 类型)</strong></p><p>常见的pl参数选项</p><pre><code>-d printer          设置目标打印机为printer-n number           打印number份副本-o fitplot            根据页面大小缩放文件-o page-type=points 设置页边距  type：left right top   每英寸72点-o cpi=number       设置每英寸字符位数为number 默认是10-o lpi=number       设置每英寸行数为number 默认是6</code></pre><h2 id="检测和控制打印任务"><a href="#检测和控制打印任务" class="headerlink" title="检测和控制打印任务"></a>检测和控制打印任务</h2><p><strong>lpstat命令 显示打印系统状态</strong></p><p>常见的lpstat参数选项</p><pre><code>-a [printer]          显示打印机的打印队列状态-d                    显示系统的默认打印机设备名-r                    显示打印服务器状态-s                    显示状态汇总报告-t                    显示完整的状态报告</code></pre><p><strong>lpq命令 显示打印队列状态</strong></p><p>显示系统默认打印机状态：<code>lpq</code><br>可使用-P命令切换打印机</p><p><strong>lprm与cancel命令 删除打印任务</strong></p><pre><code>lprm 123 将系统默认打印机的123号人物删除lprm -P printer 123 将打印机printer的123号人物删除</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、软件包管理&quot;&gt;&lt;a href=&quot;#一、软件包管理&quot; class=&quot;headerlink&quot; title=&quot;一、软件包管理&quot;&gt;&lt;/a&gt;一、软件包管理&lt;/h1&gt;&lt;p&gt;下面各命令都以Debian类为例，包含ubuntu&lt;/p&gt;
&lt;p&gt;Debian类的系统  使用的低级工具为dpkg      高级工具为apt-get、aptitude&lt;/p&gt;
&lt;h2 id=&quot;常见的软件包管理任务&quot;&gt;&lt;a href=&quot;#常见的软件包管理任务&quot; class=&quot;headerlink&quot; title=&quot;常见的软件包管理任务&quot;&gt;&lt;/a&gt;常见的软件包管理任务&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在库里面查找软件包&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get update
apt-cache search search_string       
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="linux" scheme="http://charonxu.cn/tags/linux/"/>
    
  </entry>
  
</feed>
