<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode刷题记录</title>
      <link href="2021/02/09/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>2021/02/09/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令总结(三、常见任务和主要工具)</title>
      <link href="2021/02/01/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%933/"/>
      <url>2021/02/01/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%933/</url>
      
        <content type="html"><![CDATA[<h1 id="一、软件包管理"><a href="#一、软件包管理" class="headerlink" title="一、软件包管理"></a>一、软件包管理</h1><p>下面各命令都以Debian类为例，包含ubuntu</p><p>Debian类的系统  使用的低级工具为dpkg      高级工具为apt-get、aptitude</p><h2 id="常见的软件包管理任务"><a href="#常见的软件包管理任务" class="headerlink" title="常见的软件包管理任务"></a>常见的软件包管理任务</h2><p><strong>在库里面查找软件包</strong></p><pre><code>apt-get updateapt-cache search search_string       </code></pre><a id="more"></a><p><strong>安装库中的软件包</strong></p><pre><code>apt-get updateapt-get install package_name    package_name 是软件包名称</code></pre><p><strong>更新库中的软件包</strong></p><pre><code>apt-get updateapt-get upgrade</code></pre><p><strong>安装软件包文件中的软件包</strong></p><pre><code>dpkg --install package_file     package_file 是软件包文件</code></pre><p><strong>更新软件包文件中的软件包</strong></p><pre><code>dpkg --install package_file</code></pre><p><strong>删除软件包</strong></p><pre><code>apt-get remove package_name</code></pre><p><strong>列出已安装的软件包列表</strong></p><pre><code>dpkg --list   或   dpkg -l</code></pre><p><strong>判断软件包是否安装</strong></p><pre><code>dpkg --status package_name</code></pre><p><strong>显示已安装软件包的相关信息</strong></p><pre><code>apt-cache show package_name</code></pre><p><strong>查看某具体文件由哪个软件包安装得到</strong></p><pre><code>dpkg --search file_name</code></pre><h1 id="二、存储介质"><a href="#二、存储介质" class="headerlink" title="二、存储介质"></a>二、存储介质</h1><h2 id="挂载、卸载存储设备"><a href="#挂载、卸载存储设备" class="headerlink" title="挂载、卸载存储设备"></a>挂载、卸载存储设备</h2><p><strong>查看已挂载的文件系统列表</strong></p><p>mount命令 用于文件系统挂载 ，不带参数时 该命令会调出目前已经挂载的文件系统列表。</p><p>会显示    <code>文件系统名称  on 路径 类型名 </code></p><p>umount命令可卸载设备 使用为 umount+路径</p><p>使用-t参数可以指定文件系统类型 使用方式为： </p><pre><code>mount -t 类型 文件系统名 挂载在何处</code></pre><p><strong>确定设备名称</strong></p><p>所有设备所在的目录为 /dev 目录</p><p>Linux存储设备名称：</p><pre><code>/dev/fd*             软盘驱动器/dev/hd*             较旧系统上的IDE硬盘/dev/lp*             打印机设备/dev/sd*             SCSI硬盘/dev/sr*             光驱</code></pre><h2 id="创建新的文件系统"><a href="#创建新的文件系统" class="headerlink" title="创建新的文件系统"></a>创建新的文件系统</h2><p><strong>mkfs命令 创建新的文件系统</strong></p><pre><code>使用用例：sudo mkfs -t ext3 /dev/sdb1创建一个类型为ext3的文件系统,位置在 /dev/sdb1</code></pre><h1 id="三、网络命令"><a href="#三、网络命令" class="headerlink" title="三、网络命令"></a>三、网络命令</h1><h2 id="检查、检测网络"><a href="#检查、检测网络" class="headerlink" title="检查、检测网络"></a>检查、检测网络</h2><p><strong>ping命令 向网络主机发送特殊数据包</strong></p><p>常用于测试网络连通性</p><pre><code>ping [参数] [ip地址]            可不加参数相关参数:  -c 指定发送次数   例如:  ping -c 10 charonxu.cn  向网站发送10次数据包使用 ctrl+C 终止程序 如果数据包丢失0% 则表示网络运行正常  默认传送数据时间间隔为1s</code></pre><p><strong>tracerouer命令 跟踪网络数据包的传输路径</strong></p><p>会显示文件通过网络从本地系统传输到指定主机过程中所有停靠点的列表</p><pre><code>traceroute [网址]</code></pre><p>在列表中会列出主机名、IP地址以及运行状态信息  包含文件从本地系统到路由器3次往返时间</p><p>对于不提供身份信息的路由器 会用星号代替</p><p><strong>netstat命令  检查网络设置及相关统计数据 （显示网络相关信息）</strong></p><pre><code>netstat [参数]相关参数: -t TCP协议   -u UDP协议   -l 监听   -r 路由  -n 显示IP地址和端口号 常用例子: netstat -tlun  查看本机监听的端口   netstat -an 查看本机所有的网络连接          netstat -rn 查看本机路由表</code></pre><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p><strong>who命令 查看当前在线用户</strong></p><pre><code>who 无参数          显示的是当前机器下在线人数</code></pre><p><strong>write命令 给其他在线用户发信息</strong></p><pre><code>write [用户名]      然后换行输入发送的信息  ctrl+C结束</code></pre><p><strong>wall命令 给所有在线用户发送广播信息</strong></p><pre><code>wall [message]是write all 的缩写</code></pre><p><strong>mail命令 查看电子邮件</strong></p><pre><code>mail [用户]        换行输入内容</code></pre><p><strong>lastlog 检查某特定用户上次登陆的时间</strong></p><pre><code>last -u [用户UID]</code></pre><h2 id="通过网络传输文件"><a href="#通过网络传输文件" class="headerlink" title="通过网络传输文件"></a>通过网络传输文件</h2><p><strong>ftp命令  采用FTP（文件传输协议）传输文件</strong></p><p>ftp是不安全的协议，因为它以明文的方式传送账户名以及密码。<br>这意味着信息未进行加密，任何人都可以看到。</p><p>因此，所有使用FTP协议进行网络文件传输都是由匿名FTP服务器处理的。</p><p>ftp命令实例:</p><pre><code>ftp fileserver      启动ftp程序，建立与FTP服务器fileserver的连接之后会提示 使用用户名何用户密码登录 某些服务器接收空密码 某些服务器需要以邮件地址的格式之后就可以进行操作</code></pre><p><strong>lftp命令 更好的ftp</strong></p><p>与传统的ftp程序功能类似但有很多额外的便利功能,包括多协议支持(HTTP)，下载失败时自动重新尝试、后台进程支持、</p><p>Tab键完成文件名输入等许多其他的功能。<br><strong>wget命令 非交互式网络下载工具</strong></p><p>该命令既可以从网站上下载内容 也可以从FTP站点下载。</p><pre><code>wget [参数] [URL]参数选项很多 支持递归下载、后台文件下载以及继续下载被下载的文件等操作 可使用man手册页查看</code></pre><h2 id="与远程主机的安全通信"><a href="#与远程主机的安全通信" class="headerlink" title="与远程主机的安全通信"></a>与远程主机的安全通信</h2><p><strong>ssh命令 安全登录远程计算机</strong></p><p>ssh协议是为了解决明文传送的问题，解决了与远程主机进行安全通信的两个基本问题：</p><p>1.该协议能验证远程主机的身分是否真实，避免中间人攻击。</p><p>2.该协议将本机与远程主机之间的通信内容全部加密。</p><p>使用ssh客户端程序与远程主机remote-sys建立连接举例：</p><pre><code>ssh remote-sys      首次尝试连接会提示不能确定远程主机真实性的消息     一旦建立连接 会提示用户输入密码输入密码后会进入到远程shell对话   使用exit命令可断开连接   恢复本地shell对话使用非本地系统的用户名也可以登录 例如远程系统上有bob账户 可使用如下命令登录：ssh bob@remote-sysssh命令除了能开启远程系统上的shell对话外，也能执行单个简单命令：ssh remote-sys free    在远程主机上执行free命令 获得可用内存使用简单命令时想把结果输出到本地系统文件中：   ssh remote-sys 'ls *' > out.txt若是想直接输出到远程系统的文件中应该将重定义符号和文件名同置于引号中： ssh remote-sys 'ls * > out.txt' </code></pre><p><strong>scp和sftp命令 安全传输文件</strong></p><p>scp命令与cp命令类似，差别在于scp命令的源或目的地路径前面多个远程主机号和冒号。</p><pre><code>使用scp命令在远程主机home目录下将out.txt文件复制到本地系统中的当前目录下操作如下：    scp remote-sys:out.txt .如果不是使用本地用户名登录，则需要加用户名前缀：    scp bob@remote-sys:out.txt .</code></pre><p>sftp是ftp的安全版本 sftp使用SSH加密隧道传输信息 而不是以明文方式传输。</p><p>sftp不需要远程主机上运行FTP服务器，仅需要SSH服务器，这意味着任何与SSH客户端连接的远程机器都可以当作FTP服务器使用。</p><hr><h1 id="四、文件搜索"><a href="#四、文件搜索" class="headerlink" title="四、文件搜索"></a>四、文件搜索</h1><h2 id="locate命令-较简单的方式查找文件"><a href="#locate命令-较简单的方式查找文件" class="headerlink" title="locate命令 较简单的方式查找文件"></a>locate命令 较简单的方式查找文件</h2><p>查找目录名以zip开头的文件</p><pre><code>locate ziplocate bin/zip      其中bin限制了路径，查找bin路径下以zip开头的文件</code></pre><p> locate 与 find 不同: find 是去硬盘找，locate 只在 /var/lib/slocate 资料库中找。</p><p>locate 的速度比 find 快，它并不是真的查找，而是查数据库，一般文件数据库在 /var/lib/slocate/slocate.db 中，所以 locate 的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库 ，命令为： <code>updatedb</code></p><h2 id="find命令-较复杂的方式查找文件"><a href="#find命令-较复杂的方式查找文件" class="headerlink" title="find命令 较复杂的方式查找文件"></a>find命令 较复杂的方式查找文件</h2><h3 id="test选项"><a href="#test选项" class="headerlink" title="test选项"></a>test选项</h3><p>语法: find [搜索范围] [匹配条件]</p><p><strong>根据文件名搜索</strong></p><pre><code>find / -name file_name   / 表示范围，全局范围下  file_name表示搜索的文件名称find ~ -name 's.txt'  例子</code></pre><p><strong>根据文件大小搜索</strong></p><pre><code>find / -size +204800   查询大小大于100M的文件其中 +n表示大于n -n表示小于n n等于n  在linux系统中   一个数据块=0.5K 100MB=204800数据块是linux存储文件的单位</code></pre><p><strong>根据时间搜索</strong></p><pre><code>find / -amin n    查询当前目录下过去n分钟被读取过的文件-amin n 在过去n分钟被读取过    -cmin n 在过去n分钟被修改过-atime n 在过去n天被读取过     -ctime n 在过去n天被修改过   这四个方式使用同上 n支持+-=</code></pre><p><strong>根据文件类型搜索</strong></p><pre><code>find / -type file_type file_name其中file_type表示文件类型 常用的有:  f:一般文件  d:目录  l:软链接文件  s:socket</code></pre><p><strong>多个参数选项同用</strong></p><pre><code>find ~ -type f -name "*.JPG" -size +1M | wc -l输出文件种类为普通文件 名字以JPG为后缀 大小大于1M 的文件数量</code></pre><p><strong>find命令的逻辑操作符</strong> </p><pre><code> -a 两个条件同时满足     -o 两个条件满足任意一个即可   () 多个检测条件时 默认情况下 find从左向右 扰乱默认顺序</code></pre><h3 id="action选项"><a href="#action选项" class="headerlink" title="action选项"></a>action选项</h3><p>预定义的find命令操作：</p><pre><code>-delete      删除匹配的文件-ls          对匹配的文件进行ls操作-print       将匹配的文件的全路径以默认形式输出 是默认操作-quit        一旦匹配成功就退出</code></pre><p>参数需要加在命令的最后面    注意与test选项的前后关系</p><p><strong>用户自定义操作</strong></p><pre><code>将find查找的文件直接进行某种操作 find / -name file_name -exec ls -l &#123;&#125; \;其中 / 表示路径   file_name 查找文件名    ls -l  进行什么操作   其它东西格式固定将 -exec 换成 -ok 则在操作每个文件时都会询问是否进行操作</code></pre><h3 id="option选项"><a href="#option选项" class="headerlink" title="option选项"></a>option选项</h3><p>find命令的常用option选项：</p><pre><code>-depth    引导find程序处理目录前先处理目录内的文件，使用-delete操作时 会自动调用-maxdepth levels   当执行测试条件行为时，设置find程序陷入目录数的最大级别数-mindepth levels   最小级别数-mount    引导find程序不去遍历挂在在其他文件系统上的目录-noleaf   优化搜索 </code></pre><hr><h1 id="五、归档与备份"><a href="#五、归档与备份" class="headerlink" title="五、归档与备份"></a>五、归档与备份</h1><h2 id="文件压缩与归档"><a href="#文件压缩与归档" class="headerlink" title="文件压缩与归档"></a>文件压缩与归档</h2><p><strong>gzip命令 文件压缩与解压缩</strong></p><pre><code>gzip file_name     压缩文件file_namegunzip file_name  或者  gzip -d file_name     解压缩文件注意: 在linux系统下gzip命令只能压缩文件 不可以压缩目录   并且   压缩后文件消失 不保留原文件</code></pre><p>gzip参数选项：</p><pre><code>-c    将输出内容写到标准输出端口并且保留原有文件-d    解压缩 加上此选项 gzip命令类似于 gunzip-f    强制压缩 即便原文件的压缩版本已存在 -h    显示有用信息  --help-l    列出所有压缩文件的压缩统计-r    递归压缩-t    检验压缩文件的完整性-v    压缩时显示详细信息-number   设定压缩级别  number从1-9 速度依次变慢 压缩比变大</code></pre><p><strong>tar命令 打包压缩目录</strong>  </p><pre><code>tar 选项[-cvfz] 压缩后目录名 需要压缩的目录参数含义:  -c 打包   -v 显示详细信息   -f 指定文件名   -z 打包同时压缩 如果不使用 -z 命令 则是打包目录  需再使用 gzip 命令进行压缩tar命令解压缩语法:  tar -zxvf 压缩文件名参数含义:  -x 解包   -v 显示详细信息   -f 指定文件名   -z 解压缩</code></pre><p><strong>zip命令 压缩文件或目录</strong></p><pre><code>zip 压缩后文件名 需要压缩文件名    使用 -r 参数 可以压缩目录解压缩:    unzip 压缩后文件名zip 可以保留原文件</code></pre><p><strong>bzip2命令 压缩文件(牺牲速度换取高压缩比)</strong></p><pre><code>bzip2 file_name   添加参数 -k 可以保留原文件bunzip2   解压缩文件    添加参数 -k 保留原压缩文件</code></pre><h2 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h2><p><strong>rsync命令 远程文件、目录的同步</strong></p><p>rsync命令调用方式： <code>rsync options source destination</code></p><p>其中sourse与destination必须有一个本地文件，不允许远程系统相互复制。</p><p>常用参数options：</p><pre><code>-a     用于归档  进行递归归档并保存文件属性-v     详细输出</code></pre><h1 id="六、正则表达式"><a href="#六、正则表达式" class="headerlink" title="六、正则表达式"></a>六、正则表达式</h1><h2 id="grep命令-文本搜索"><a href="#grep命令-文本搜索" class="headerlink" title="grep命令 文本搜索"></a>grep命令 文本搜索</h2><pre><code>grep [option] regex [file...]        字符串regex代表某个正则表达式  [file...]表示搜索文件名 可使用通配符进行多文件搜索参数选项：-i    忽略大小写-v    不匹配，输出不匹配的所有行-c    输出匹配项的数目-l    输出匹配项文件名而不是输出匹配行本身-L    与-l类似，单输出的是不包含匹配项的文件名-n    在每个匹配行前面加上该行在文件内的行号-h    进行多文件搜索时，抑制文件名输出</code></pre><p>举例：</p><pre><code>grep abc list*.txt   对list*.txt进行多文件搜索文本abc 输出匹配行grep -l abc list*.txt  同上 但输出的是文件名grep -L abc list*.txt  同上 但输出的是不匹配文件的文件名</code></pre><h2 id="元字符和文字"><a href="#元字符和文字" class="headerlink" title="元字符和文字"></a>元字符和文字</h2><p>正则表达式的元字符包括下列字符：</p><pre><code>^ $ . [ ] &#123; &#125; - ? * + ( ) | \</code></pre><p>其他字符被当作文字字符，但在极少情况下，\ 字符用来创建元序列，以及用来对元字符进行转义</p><h2 id="任意字符"><a href="#任意字符" class="headerlink" title="任意字符"></a>任意字符</h2><p>匹配任意字符的元字符 <code>.</code><br>例如使用命令查询     <code>grep &#39;.zip&#39; dirlist.txt</code></p><p>会查询包含zip的长度大于等于4的行 即<code>·</code>不能代替空字符。</p><h2 id="锚"><a href="#锚" class="headerlink" title="锚"></a>锚</h2><p>插入符(^)和美元符号($)在正则表达式中被当作锚，也就是说正则表达式只与行的开头(^)或末尾($)进行匹配。</p><pre><code>grep -h &#39;^zip&#39; dirlist.txtzipzipcloakzipgrep显示的行都是以zip开头grep -h &#39;zip$&#39; dirlist.txtasdazipsdazip显示的行都是以zip结尾grep -h &#39;^zip$&#39; dirlist.txtzip显示行就是zip如果使用正则表达式&#39;^$&#39; ，则匹配的应该是空行</code></pre><h2 id="中括号表达式和字符类"><a href="#中括号表达式和字符类" class="headerlink" title="中括号表达式和字符类"></a>中括号表达式和字符类</h2><p>中括号除了用于匹配正则表达式中给定位置的定义字符外，还可用于匹配指定字符集中的单个字符。</p><pre><code>grep -h [bg]zip dirlist.txtbzipgzip</code></pre><p>某些字符在[] 中巨有不同的含义，^在中括号中表示否定，-表示字符范围。</p><p><strong>否定</strong></p><p>如果中括号中的第一个字符是插入符(^),则表示剩下的字符被当作不应该在指定位置出现的字符集。</p><pre><code>grep -h&#39;[^bg]zip&#39; dirlist.txtbunzipgunzipunzip并且[]位置只能限制一个字符</code></pre><p><strong>传统字符范围</strong></p><pre><code>查找首字母为大写的行grep -h &#39;^[A-Z]&#39; dirlist.txt可支持多个范围grep -h &#39;^[A-Za-z0-9]&#39; dirtlist.txt取消连字符的特殊用法 作为普通的字符grep -h &#39;[-AZ]&#39; dirtlist.txt    只作为单一字符使用</code></pre><p><strong>POSIX字符类</strong></p><pre><code>[:alnum:]           字母字符和数字字符 (a-z A-Z 0-9)[:word:]            同上 多了个下划线&#39;_&#39;[:alpha:]           字母字符[:blank:]           包括空格和制表符[:cntrl:]           ASCII控制码 0-31 127[:digit:]           数字字符[:graph:]           可见字符  33-126[:lower:]           小写字母[:punct:]           标点符号字符  #￥%……&amp;*等[:print:]           可打印字符[:space:]           空白字符  空格符、制表符、回车符、换行符等[:upper:]           大写字母[:xdight:]          用于表示十六进制字母  0-9 A-F a-f</code></pre><p><strong>或选项</strong></p><p>或选项，用元字符’|’表示</p><p>grep 中 -E 选项 用于延伸正则表达式</p><pre><code>echo &#39;AAA&#39; | grep -E &#39;AAA|BBB&#39;    使用引号防止当作管道操作使用对于文本结果匹配字符串AAA或BBBecho -E &#39;^(zip|gz|bz)&#39; dirlisst.txt使用()将或选项的左右元素与其他符号分开</code></pre><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p><strong>？ 匹配某元素0次或1次</strong></p><p>匹配的是前面的一个字符</p><pre><code>grep -E &#39;\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]$&#39;(555) 123-4567555 123-4567(与)可出现0次或以1次</code></pre><p><strong>* 匹配某元素多次或零次</strong></p><p>匹配上一个字符任意次        必须保持同上        用法同？类似</p><p><strong>+ 匹配某元素一次或多次</strong></p><p>+元字符与*元字符很相似，但是+元字符要求前面的元素至少出现一次</p><p><strong>{} 以指定次数匹配某元素</strong></p><p>指定匹配次数</p><pre><code>&#123;n&#125;         前面的元素恰好出现n次匹配&#123;n,m&#125;       前面的元素出现次数在n~m之间&#123;n,&#125;        前面的元素出现次数超过n次则匹配&#123;,m&#125;        前面的元素不超过m次则匹配</code></pre><h1 id="七、文本处理"><a href="#七、文本处理" class="headerlink" title="七、文本处理"></a>七、文本处理</h1><p>温故知新</p><h2 id="cat命令-进行文件之间的拼接并且输出到标准输出"><a href="#cat命令-进行文件之间的拼接并且输出到标准输出" class="headerlink" title="cat命令 进行文件之间的拼接并且输出到标准输出"></a>cat命令 进行文件之间的拼接并且输出到标准输出</h2><pre><code>cat &gt; out.txt准备向out.txt文件输入内容 以 Ctrl+D 表示结束使用-A选项可以显示文本内容：cat -A out.txt显示文本内容 其中&quot;^I&quot;表示制表符  末尾出现&quot;$&quot;表示末尾空格cat最常用选项：-n 对行编号          -s 禁止输出多个空白行</code></pre><h2 id="sort命令-对文本进行排序"><a href="#sort命令-对文本进行排序" class="headerlink" title="sort命令 对文本进行排序"></a>sort命令 对文本进行排序</h2><pre><code>sort &gt; out.txt       输入三行文本  Ctrl+D 结束baccat out.txt          查看文本 已经排好序abc</code></pre><p>sort支持多文件排序</p><pre><code>sort file1 file2 fil3 &gt; final.txt   将结果融合为单个文本</code></pre><p>常见的sort选项参数：</p><pre><code>-b       默认情况下会从行的开头字符排序，此选项可忽略行开头空格，从第一个非空格字符开始-f       排序时不区分字符大小写-n       基于字符串的长度进行排序-f       逆序排序  将结果按照逆序结果输出-o       将排序结果输出到文件而不是标准输出-k       -key=[field1,field2]间的字符进行排序 对第几个字段进行排序-r       逆序排列 </code></pre><p>举例：</p><pre><code>sort -k 3.7nbr -k 3.1nbr out.txt上述例子表示sort支持多参数，3.7表示按第三个字段的第七个字符排序 nbr指参数</code></pre><h2 id="uniq命令-通知或省略重复的行"><a href="#uniq命令-通知或省略重复的行" class="headerlink" title="uniq命令 通知或省略重复的行"></a>uniq命令 通知或省略重复的行</h2><p>重复的行是相对于上一行而言，不是整个文本</p><p>常见的uniq选项参数：</p><pre><code>-c       输出重复行列表，并且在行的前面加上其出现的次数-d       只输出重复行，而不包括单独行-fn      忽略每行前n个字段 字段默认以空格分开-i       行与行之间比较时忽略大小写-sn      跳过每行前n个字符-u       仅输出不重复的行 该选项时默认的</code></pre><h2 id="切片和切块"><a href="#切片和切块" class="headerlink" title="切片和切块"></a>切片和切块</h2><p><strong>cut命令 删除文本行中的部分内容</strong></p><p>常见的cut选项参数：</p><pre><code>-c char_list      从文本行中提取char_list定义的部分内容，此列表可能包含多个：分割的范围   -c 7-10 提取第7-10字符-f field_list     从文本行中提取field_list定义的一个或多个字段，此列表可能包含多个：分割的范围   -f 3 即表示提取第三个字段-d delim_char     指定-f后，使用delim_char作为字符分界符，默认时，必须使用单个Tab隔开   -d &#39;:&#39; 将：作为分界符--complement      从文本中提取整行，除了那些由-c和/或-f指定的部分</code></pre><p><strong>paste命令 合并文本行</strong></p><p>向文件中增加一个或多个文本列</p><p>举例：<code>paste a.txt b.txt </code>   将a的文本按顺序加入b的列中</p><p><strong>join命令 连接两文件中具体相同字段的行</strong></p><p>如果两个文件具有相同的字段，就会将两个文本连接 。</p><p>文件必须实现依据共有关键字段排序，而且默认使用空格作为分界符。</p><h2 id="文本比较"><a href="#文本比较" class="headerlink" title="文本比较"></a>文本比较</h2><p><strong>comm命令 逐行比较已排序文本</strong></p><p>comm命令对结果会返回三列标准输出，第一列显示的是第一个文件独有的行，第二列显示的是第二个文件独有的行，第三列显示的是两个文件所共有的行(即相同的行内容)。</p><p>comm命令支持参数 -n n的值为1，2，3，表示可省略第几列的内容 </p><p>comm -2 就是省略第二列  comm -12 就是省略第12列</p><p><strong>diff命令 逐行比较文件</strong></p><pre><code>diff a.txt b.txt  对比a b文本</code></pre><p>该命令会对两个文本进行逐行对比 然后标准输出如何修改才能使两个文本相同</p><p>diff改变命令：</p><pre><code>r1ar2      将第二个文件中r2位置的行添加到第一个文件中的r1位置处r1cr2      用第二个文件r2位置的行替换第一个文件r1位置的行r1dr2      删除第一个文件r1处的行，并且删除的内容作为第二个文件r2位置的行</code></pre><p>标准输出中每个改变命令后会说明如何修改，其中’&lt;’表示删除行的内容  ‘&gt;’表示添加行的内容</p><p>使用 -c 参数 则会使用上下文格式的输出结果<br>例如有两个文本如下：</p><pre><code>a.txt  b.txta          bb          cc          dd          e</code></pre><p>使用 -c 参数后：</p><pre><code>diff -c a.txt b.txt*** a.txt    2021-02-07 22:50:23.254269194 +0800--- b.txt    2021-02-07 22:50:34.082966633 +0800****************** 1,4 ****- a  b  c  d--- 1,4 ----  b  c  d+ e</code></pre><p>diff上下文格式差异标识符：</p><pre><code>(无)      该行表示上下文文本，表示两个文件共有的行-         缺少的行，指此行在第一个文件中出现，第二个文件没有+         多余的行，指此行在第二个文件中出现，第一个文件没有!         改变的行，两个版本的行内容都会显示出来，每一个都会出现在差异组中相应的部分</code></pre><p>使用 -u 参数 则会使用统一格式的输出结果</p><pre><code>diff -u a.txt b.txt--- a.txt    2021-02-07 22:50:23.254269194 +0800+++ b.txt    2021-02-07 22:50:34.082966633 +0800@@ -1,4 +1,4 @@     表示两文件各自的行数-a b c d+e</code></pre><p>diff统一格式差异标识符：</p><pre><code>(无)        两个文件共有的行           可以理解为无变动-           相对于第二个文件而言，没有的行    可以理解为删除该行+           相对于第一个文件多余的行          可以理解为增加此行</code></pre><h2 id="非交互式文本编辑"><a href="#非交互式文本编辑" class="headerlink" title="非交互式文本编辑"></a>非交互式文本编辑</h2><p><strong>tr命令 替换或删除字符</strong></p><p>tr可对标准输入进行操作并且将结果以标准输出的形式输出。</p><p>字符集的形式包括 枚举列表(ABCD)、字符范围(A-Z)、POSIX字符类([:lower:])</p><p>将小写字母替换为大写字母：  <code>echo &#39;lower&#39; | a-z A-Z</code></p><p>使用tr命令可删除字符：<code>tr -d &#39;\r&#39; &lt;dos_file&gt; unix_file</code> </p><p>其中dos_file是需要操作的文件，unix_file是转化的结果文件(会创建) &lt;…&gt; 是固定格式</p><p>其他参数：    <code>-s   删除重复出现的字符 ，必须是相邻的  并且使用多位于标准输入输出中</code></p><p><strong>sed命令 用于文本过滤和转换的流编辑器</strong></p><p>sed是sream editor流式编辑器，可以对文本流、指定文件集或标准输入进行文本编辑。</p><p>sed命令功能强大，异常复杂，所以并未涉及到所有语法。</p><pre><code>echo &#39;front&#39; | sed &#39;s/front/back&#39;backecho &#39;front&#39; | sed &#39;s_front_back&#39;back由上述两个指令可知，sed中，替换命令可由字母s代替，其后紧跟被替换字符以及替换成何字符。sed支持任意字符作为分界符，紧跟&#39;s&#39;后变是分界符。指定行进行替换echo &#39;front&#39; | sed &#39;1s/front/back&#39;     只对输入流的第一行进行替换echo &#39;front&#39; | sed &#39;2s/front/back&#39;     只对输入流的第二行进行替换</code></pre><p>此替换又名地址表示法 在’s’前加参数，常用的地址表示法有：</p><pre><code>n             n是正整数 表示行号$             表示最后一行addr1,addr2   表示行范围 对addr1至addr2的行进行替换first~step    表示从first行开始，间隔为step行进行替换addr1,+n      表示从addr1行开始，向后n行进行替换addr!         除了addr外的所有行 addr可以用上面的任意形式替换</code></pre><p>使用sed命令的特点，就是替换字符串后面可以紧跟可选择标识符，最重要的就是-g，该标志表示对所有匹配项进行替换操作，而不是只对第一个匹配项替换。</p><pre><code>echo &quot;aaabbbccc&quot; | sed &#39;s/b/B&#39;      对第一个匹配项进行替换aaaBbbcccecho &quot;aaabbbccc&quot; | sed &#39;s/b/B/g&#39;    对所有匹配项进行替换aaaBBBccc</code></pre><p><strong>aspell命令 交互式拼写检查工具</strong></p><pre><code>aspell check filename   检查文件中的拼写错误</code></pre><h1 id="八、格式化输出"><a href="#八、格式化输出" class="headerlink" title="八、格式化输出"></a>八、格式化输出</h1><h2 id="简单的格式化工具"><a href="#简单的格式化工具" class="headerlink" title="简单的格式化工具"></a>简单的格式化工具</h2><p><strong>nl命令 对行进行标号</strong></p><p>nl与cat-n 相似，都能显示行号</p><pre><code>nl out.txt    标准输出out.txt文件内容，并显示行号</code></pre><p>nl既支持多文件名作为命令行参数，也支持标准输入。</p><p>nl标号时支持逻辑页的概念，逻辑页可分解为标题、正文、页脚</p><p>三个部分表示如下：</p><pre><code>\:\:\:        逻辑页页眉开头\:\:          逻辑页正文开头\:            逻辑页页尾开头</code></pre><p>常用的nl参数选项：</p><pre><code>-b style   按照style格式对正文进行编号，style选项如下：           a 对每行编号   t 仅对非空白行编号，默认的   n 不对任何行标号   pregexp 只对与正则表达式匹配的行编号 -f style   按照style格式对页脚进行编号-h style   按照style格式对标题进行编号-p         在每个逻辑页开始不在进行页编码重置-s string  在每行行号后增肌string作为分界符，默认是Tab-v number  将每个逻辑页的第一个行号设为number,默认是1</code></pre><p><strong>fold命令 将文本中的行长度设定为指定长度</strong></p><pre><code>使用-w选项定长将文件分割：fold -w 3 out.txt   将文件以每行三个字符的长度分割  默认是80个字符宽fold断行时不会考虑单词边界，使用-s选项，在到达指定长度的前的最后一个空格处将文本断开fold -w 3 out.txt -s</code></pre><p><strong>fmt命令 简单的文本格式化工具</strong></p><p>使用fmt命令将文件定长格式化：<code>fmt -w 50 out.txt</code>,每行按50长度分割</p><p>默认情况下，空白行、单词之间的空格和缩进都保留在输出结果中，不同缩进量的连续输入行并不进行拼接；制表符会在输入中扩展并直接输出。</p><p>fmt的常用参数选项：</p><pre><code>-c              保留前两行的缩进，随后的行斗鱼第二行的缩进对齐-p strnig       只格式化以string为开头的行-s              将会只根据指定的列宽截断行，断航不会与其他行合并-u              字符间隔统一，字符间隔一个空格，句子间隔两个空格-w width        指定每行文本不超过width个字符 默认值75</code></pre><p><strong>pr命令 格式化打印文本</strong></p><p>pr命令可用于给文本标页码，打印文本时，每页的顶部与尾部都会有几行空格。</p><pre><code>pr -l 15 -w 50 out.txt每页15行，每行50个字符</code></pre><p><strong>printf命令 格式化并打包数据</strong></p><p>用法：</p><pre><code>printf &quot;format&quot; argumentprintf &quot;I&#39;m a %s\n&quot; student输出 I&#39;m a student</code></pre><p>printf的数据类型指定符参照c语言 ，d 十进制整数 f 浮点数 o 八进制  x 整数格式化为十六进制 小写  X 大写</p><h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><h2 id="准备打印文件"><a href="#准备打印文件" class="headerlink" title="准备打印文件"></a>准备打印文件</h2><p><strong>pr命令 将文本文件转换为打印文件</strong></p><p>pr命令可用于调整文本以适应特定纸张的大小，并且可自主选择页眉和页边距。</p><pre><code>ls /usr/bin | pr -3 -w 65 | head列出/use/bin目录下的文件 用pr命令 格式化为分页、三列的输出</code></pre><p>常见的pr参数选项</p><pre><code>+first[:last]       输入一个从first开始以last结束的页范围-colnums            将页的内容分为指定的colnums列-a                  默认情况下，多列输出是垂直列出的，增加-a选项便是水平输出-d                  隔行打印输出-n                     对行进行编号</code></pre><h2 id="向打印机发送打印任务"><a href="#向打印机发送打印任务" class="headerlink" title="向打印机发送打印任务"></a>向打印机发送打印任务</h2><p><strong>lpr命令 打印文件(Berkeley类型)</strong></p><p>既支持标准输入，也可以用于管道传输</p><p>将文件发送至不同的打印机，使用-P选项，实例：</p><pre><code>lpr -P printer_name         print_name表示目标打印机名称</code></pre><p>查看系统打印机列表</p><pre><code>lpstat -a</code></pre><p>常见的lpr参数选项</p><pre><code>-# number           打印number份副本-p                  每一页都包括日期、时间、工作名称和页码的页眉用阴影打印出来-P printer          指定用于打印输出的打印机名-r                     打印结束后删除文件</code></pre><p><strong>lp命令 打印文件(System V 类型)</strong></p><p>常见的pl参数选项</p><pre><code>-d printer          设置目标打印机为printer-n number           打印number份副本-o fitplot            根据页面大小缩放文件-o page-type=points 设置页边距  type：left right top   每英寸72点-o cpi=number       设置每英寸字符位数为number 默认是10-o lpi=number       设置每英寸行数为number 默认是6</code></pre><h2 id="检测和控制打印任务"><a href="#检测和控制打印任务" class="headerlink" title="检测和控制打印任务"></a>检测和控制打印任务</h2><p><strong>lpstat命令 显示打印系统状态</strong></p><p>常见的lpstat参数选项</p><pre><code>-a [printer]          显示打印机的打印队列状态-d                    显示系统的默认打印机设备名-r                    显示打印服务器状态-s                    显示状态汇总报告-t                    显示完整的状态报告</code></pre><p><strong>lpq命令 显示打印队列状态</strong></p><p>显示系统默认打印机状态：<code>lpq</code><br>可使用-P命令切换打印机</p><p><strong>lprm与cancel命令 删除打印任务</strong></p><pre><code>lprm 123 将系统默认打印机的123号人物删除lprm -P printer 123 将打印机printer的123号人物删除</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
